C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CYLIB
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\CyLib.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DEBUG) W
                    -L(2) PR(.\DP8051\DP8051_Keil_951\Debug/CyLib.lst) CD OT(5,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\CyLib.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: CyLib.c
   3          * Version 5.20
   4          *
   5          *  Description:
   6          *   Provides a system API for the clocking, interrupts and watchdog timer.
   7          *
   8          *  Note:
   9          *   Documentation of the API's in this file is located in the
  10          *   System Reference Guide provided with PSoC Creator.
  11          *
  12          ********************************************************************************
  13          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions,
  15          * disclaimers, and limitations in the end user license agreement accompanying
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "CyLib.h"
  20          
  21          
  22          /*******************************************************************************
  23          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  24          * a device reset. It is set from initialize_psoc() at the early initialization
  25          * stage. In case of IAR EW IDE, initialize_psoc() is executed before the data
  26          * sections are initialized. To avoid zeroing, CyResetStatus should be placed
  27          * to the .noinit section.
  28          *******************************************************************************/
  29          CY_NOINIT uint8 CYXDATA CyResetStatus;
  30          
  31          
  32          /* Variable Vdda */
  33          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  38          
  39          
  40          /* Do not use these definitions directly in your application */
  41          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  42          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  43          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  44          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  45          
  46          
  47          /* Function Prototypes */
  48          static uint8 CyUSB_PowerOnCheck(void)  ;
  49          static void CyIMO_SetTrimValue(uint8 freq) ;
  50          static void CyBusClk_Internal_SetDivider(uint16 divider);
  51          
  52          #if(CY_PSOC5)
                  static cySysTickCallback CySysTickCallbacks[CY_SYS_SYST_NUM_OF_CALLBACKS];
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 2   

                  static void CySysTickServiceCallbacks(void);
                  uint32 CySysTickInitVar = 0u;
              #endif  /* (CY_PSOC5) */
  57          
  58          
  59          /*******************************************************************************
  60          * Function Name: CyPLL_OUT_Start
  61          ********************************************************************************
  62          *
  63          * Summary:
  64          *   Enables the PLL.  Optionally waits for it to become stable.
  65          *   Waits at least 250 us or until it is detected that the PLL is stable.
  66          *
  67          * Parameters:
  68          *   wait:
  69          *    0: Return immediately after configuration
  70          *    1: Wait for PLL lock or timeout.
  71          *
  72          * Return:
  73          *   Status
  74          *    CYRET_SUCCESS - Completed successfully
  75          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  76          *     If the input source of the clock is jittery, then the lock indication
  77          *     may not occur.  However, after the timeout has expired the generated PLL
  78          *     clock can still be used.
  79          *
  80          * Side Effects:
  81          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
  82          *  Any other use of the Fast Time Wheel will be stopped during the period of
  83          *  this function and then restored. This function also uses the 100 KHz ILO.
  84          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  85          *  this function.
  86          *
  87          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  88          *  Once Per Second interrupt may be made by interrupt routines during the period
  89          *  of this function execution. The current operation of the ILO, Central Time
  90          *  Wheel and Once Per Second interrupt are maintained during the operation of
  91          *  this function provided the reading of the Power Manager Interrupt Status
  92          *  Register is only done using the CyPmReadStatus() function.
  93          *
  94          *******************************************************************************/
  95          cystatus CyPLL_OUT_Start(uint8 wait) 
  96          {
  97   1          cystatus status = CYRET_SUCCESS;
  98   1      
  99   1          uint8 iloEnableState;
 100   1          uint8 pmTwCfg0State;
 101   1          uint8 pmTwCfg2State;
 102   1      
 103   1      
 104   1          /* Enables PLL circuit  */
 105   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 106   1      
 107   1          if(wait != 0u)
 108   1          {
 109   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
 110   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 111   2              pmTwCfg0State = CY_LIB_PM_TW_CFG0_REG;
 112   2              pmTwCfg2State = CY_LIB_PM_TW_CFG2_REG;
 113   2      
 114   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
 115   2      
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 3   

 116   2              status = CYRET_TIMEOUT;
 117   2      
 118   2              while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 119   2              {
 120   3                  /* Wait for interrupt status */
 121   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 122   3                  {
 123   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 124   4                      {
 125   5                          status = CYRET_SUCCESS;
 126   5                          break;
 127   5                      }
 128   4                  }
 129   3              }
 130   2      
 131   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 132   2              if(0u == iloEnableState)
 133   2              {
 134   3                  CyILO_Stop100K();
 135   3              }
 136   2      
 137   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0State;
 138   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2State;
 139   2          }
 140   1      
 141   1          return(status);
 142   1      }
 143          
 144          
 145          /*******************************************************************************
 146          * Function Name: CyPLL_OUT_Stop
 147          ********************************************************************************
 148          *
 149          * Summary:
 150          *  Disables the PLL.
 151          *
 152          * Parameters:
 153          *  None
 154          *
 155          * Return:
 156          *  None
 157          *
 158          *******************************************************************************/
 159          void CyPLL_OUT_Stop(void) 
 160          {
 161   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 162   1      }
 163          
 164          
 165          /*******************************************************************************
 166          * Function Name: CyPLL_OUT_SetPQ
 167          ********************************************************************************
 168          *
 169          * Summary:
 170          *  Sets the P and Q dividers and the charge pump current.
 171          *  The Frequency Out will be P/Q * Frequency In.
 172          *  The PLL must be disabled before calling this function.
 173          *
 174          * Parameters:
 175          *  uint8 pDiv:
 176          *   Valid range [8 - 255].
 177          *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 4   

 178          *  uint8 qDiv:
 179          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 180          
 181          *  uint8 current:
 182          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 183          *   datasheet for more information.
 184          *
 185          * Return:
 186          *  None
 187          *
 188          * Side Effects:
 189          *  If this function execution results in the CPU clock frequency increasing,
 190          *  then the number of clock cycles the cache will wait before it samples data
 191          *  coming back from the Flash must be adjusted by calling
 192          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 193          *  called if the CPU clock frequency is lowered in order to improve the CPU
 194          *  performance. See CyFlash_SetWaitCycles() description for more information.
 195          *
 196          *******************************************************************************/
 197          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 198          {
 199   1          /* Halt CPU in debug mode if PLL is enabled */
 200   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 201   1      
 202   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 203   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 204   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 205   1          {
 206   2              /* Set new values */
 207   2              CY_CLK_PLL_P_REG = pDiv;
 208   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 209   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 210   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 211   2          }
 212   1          else
 213   1          {
 214   2              /***********************************************************************
 215   2              * Halt CPU in debug mode if:
 216   2              * - P divider is less than required
 217   2              * - Q divider is out of range
 218   2              * - pump current is out of range
 219   2              ***********************************************************************/
 220   2              CYASSERT(0u != 0u);
 221   2          }
 222   1      
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: CyPLL_OUT_SetSource
 228          ********************************************************************************
 229          *
 230          * Summary:
 231          *  Sets the input clock source to the PLL. The PLL must be disabled before
 232          *  calling this function.
 233          *
 234          * Parameters:
 235          *   source: One of the three available PLL clock sources
 236          *    CY_PLL_SOURCE_IMO  :   IMO
 237          *    CY_PLL_SOURCE_XTAL :   MHz Crystal
 238          *    CY_PLL_SOURCE_DSI  :   DSI
 239          *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 5   

 240          * Return:
 241          *  None
 242          *
 243          * Side Effects:
 244          *  If this function execution results in the CPU clock frequency increasing,
 245          *  then the number of clock cycles the cache will wait before it samples data
 246          *  coming back from the3 Flash must be adjusted by calling
 247          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 248          *  called if the CPU clock frequency is lowered in order to improve the CPU
 249          *  performance. See CyFlash_SetWaitCycles() description for more information.
 250          *
 251          *******************************************************************************/
 252          void CyPLL_OUT_SetSource(uint8 source) 
 253          {
 254   1          /* Halt CPU in debug mode if PLL is enabled */
 255   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 256   1      
 257   1          switch(source)
 258   1          {
 259   2              case CY_PLL_SOURCE_IMO:
 260   2              case CY_PLL_SOURCE_XTAL:
 261   2              case CY_PLL_SOURCE_DSI:
 262   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 263   2              break;
 264   2      
 265   2              default:
 266   2                  CYASSERT(0u != 0u);
 267   2              break;
 268   2          }
 269   1      }
 270          
 271          
 272          /*******************************************************************************
 273          * Function Name: CyIMO_Start
 274          ********************************************************************************
 275          *
 276          * Summary:
 277          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 278          *
 279          * Parameters:
 280          *  uint8 wait:
 281          *   0: Return immediately after configuration
 282          *   1: Wait for at least 6 us for the IMO to settle.
 283          *
 284          * Return:
 285          *  None
 286          *
 287          * Side Effects:
 288          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
 289          *  Any other use of the Fast Time Wheel will be stopped during the period of
 290          *  this function and then restored. This function also uses the 100 KHz ILO.
 291          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 292          *  this function.
 293          *
 294          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 295          *  Once Per Second interrupt may be made by interrupt routines during the period
 296          *  of this function execution. The current operation of the ILO, Central Time
 297          *  Wheel and Once Per Second interrupt are maintained during the operation of
 298          *  this function provided the reading of the Power Manager Interrupt Status
 299          *  Register is only done using the CyPmReadStatus() function.
 300          *
 301          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 6   

 302          void CyIMO_Start(uint8 wait) 
 303          {
 304   1          uint8 pmFtwCfg2Reg;
 305   1          uint8 pmFtwCfg0Reg;
 306   1          uint8 ilo100KhzEnable;
 307   1      
 308   1      
 309   1          CY_LIB_PM_ACT_CFG0_REG  |= CY_LIB_PM_ACT_CFG0_IMO_EN;
 310   1          CY_LIB_PM_STBY_CFG0_REG |= CY_LIB_PM_STBY_CFG0_IMO_EN;
 311   1      
 312   1          if(0u != wait)
 313   1          {
 314   2              /* Need to turn on 100KHz ILO if it happens to not already be running.*/
 315   2              ilo100KhzEnable = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 316   2              pmFtwCfg0Reg = CY_LIB_PM_TW_CFG0_REG;
 317   2              pmFtwCfg2Reg = CY_LIB_PM_TW_CFG2_REG;
 318   2      
 319   2              CyPmFtwSetInterval(CY_LIB_CLK_IMO_FTW_TIMEOUT);
 320   2      
 321   2              while (0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 322   2              {
 323   3                  /* Wait for interrupt status */
 324   3              }
 325   2      
 326   2              if(0u == ilo100KhzEnable)
 327   2              {
 328   3                  CyILO_Stop100K();
 329   3              }
 330   2      
 331   2              CY_LIB_PM_TW_CFG0_REG = pmFtwCfg0Reg;
 332   2              CY_LIB_PM_TW_CFG2_REG = pmFtwCfg2Reg;
 333   2          }
 334   1      }
 335          
 336          
 337          /*******************************************************************************
 338          * Function Name: CyIMO_Stop
 339          ********************************************************************************
 340          *
 341          * Summary:
 342          *   Disables the IMO.
 343          *
 344          * Parameters:
 345          *  None
 346          *
 347          * Return:
 348          *  None
 349          *
 350          *******************************************************************************/
 351          void CyIMO_Stop(void) 
 352          {
 353   1          CY_LIB_PM_ACT_CFG0_REG  &= ((uint8) (~CY_LIB_PM_ACT_CFG0_IMO_EN));
 354   1          CY_LIB_PM_STBY_CFG0_REG &= ((uint8) (~CY_LIB_PM_STBY_CFG0_IMO_EN));
 355   1      }
 356          
 357          
 358          /*******************************************************************************
 359          * Function Name: CyUSB_PowerOnCheck
 360          ********************************************************************************
 361          *
 362          * Summary:
 363          *  Returns the USB power status value. A private function to cy_boot.
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 7   

 364          *
 365          * Parameters:
 366          *   None
 367          *
 368          * Return:
 369          *   uint8: one if the USB is enabled, 0 if not enabled.
 370          *
 371          *******************************************************************************/
 372          static uint8 CyUSB_PowerOnCheck(void)  
 373          {
 374   1          uint8 poweredOn = 0u;
 375   1      
 376   1          /* Check whether device is in Active or AltActive and if USB is powered on */
 377   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 378   1             (0u != (CY_LIB_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 379   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 380   1             (0u != (CY_LIB_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 381   1          {
 382   2              poweredOn = 1u;
 383   2          }
 384   1      
 385   1          return (poweredOn);
 386   1      }
 387          
 388          
 389          /*******************************************************************************
 390          * Function Name: CyIMO_SetTrimValue
 391          ********************************************************************************
 392          *
 393          * Summary:
 394          *  Sets the IMO factory trim values.
 395          *
 396          * Parameters:
 397          *  uint8 freq - frequency for which trims must be set
 398          *
 399          * Return:
 400          *  None
 401          *
 402          *******************************************************************************/
 403          static void CyIMO_SetTrimValue(uint8 freq) 
 404          {
 405   1          uint8 usbPowerOn = CyUSB_PowerOnCheck();
 406   1      
 407   1          /* If USB is powered */
 408   1          if(usbPowerOn == 1u)
 409   1          {
 410   2              /* Unlock USB write */
 411   2              CY_LIB_USB_CR1_REG &= ((uint8)(~CY_LIB_USB_CLK_EN));
 412   2          }
 413   1          switch(freq)
 414   1          {
 415   2          case CY_IMO_FREQ_3MHZ:
 416   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_3MHZ_PTR);
 417   2              break;
 418   2      
 419   2          case CY_IMO_FREQ_6MHZ:
 420   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_6MHZ_PTR);
 421   2              break;
 422   2      
 423   2          case CY_IMO_FREQ_12MHZ:
 424   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_12MHZ_PTR);
 425   2              break;
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 8   

 426   2      
 427   2          case CY_IMO_FREQ_24MHZ:
 428   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_24MHZ_PTR);
 429   2              break;
 430   2      
 431   2          case CY_IMO_FREQ_48MHZ:
 432   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_TR1_PTR);
 433   2              break;
 434   2      
 435   2          case CY_IMO_FREQ_62MHZ:
 436   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_67MHZ_PTR);
 437   2              break;
 438   2      
 439   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_80MHZ_PTR);
                      break;
              #endif  /* (CY_PSOC5) */
 444   2      
 445   2          case CY_IMO_FREQ_USB:
 446   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_USB_PTR);
 447   2      
 448   2              /* If USB is powered */
 449   2              if(usbPowerOn == 1u)
 450   2              {
 451   3                  /* Lock USB Oscillator */
 452   3                  CY_LIB_USB_CR1_REG |= CY_LIB_USB_CLK_EN;
 453   3              }
 454   2              break;
 455   2      
 456   2          default:
 457   2                  CYASSERT(0u != 0u);
 458   2              break;
 459   2          }
 460   1      
 461   1      }
 462          
 463          
 464          /*******************************************************************************
 465          * Function Name: CyIMO_SetFreq
 466          ********************************************************************************
 467          *
 468          * Summary:
 469          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 470          *
 471          * Parameters:
 472          *  freq: Frequency of IMO operation
 473          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
 474          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
 475          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 476          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 477          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 478          *       CY_IMO_FREQ_62MHZ to set 62.6 MHz
 479          *       CY_IMO_FREQ_74MHZ to set 74.7 MHz (not applicable for PSoC 3)
 480          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 481          *
 482          * Return:
 483          *  None
 484          *
 485          * Side Effects:
 486          *  If this function execution results in the CPU clock frequency increasing,
 487          *  then the number of clock cycles the cache will wait before it samples data
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 9   

 488          *  coming back from the Flash must be adjusted by calling
 489          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 490          *  called if the CPU clock frequency is lowered in order to improve the CPU
 491          *  performance. See CyFlash_SetWaitCycles() description for more information.
 492          *
 493          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 494          *  Otherwise this circuit is disabled. The USB block must be powered before
 495          *  selecting the USB setting.
 496          *
 497          *******************************************************************************/
 498          void CyIMO_SetFreq(uint8 freq) 
 499          {
 500   1          uint8 currentFreq;
 501   1          uint8 nextFreq;
 502   1      
 503   1          /***************************************************************************
 504   1          * If the IMO frequency is changed,the Trim values must also be set
 505   1          * accordingly.This requires reading the current frequency. If the new
 506   1          * frequency is faster, then set a new trim and then change the frequency,
 507   1          * otherwise change the frequency and then set new trim values.
 508   1          ***************************************************************************/
 509   1      
 510   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 511   1      
 512   1          /* Check if requested frequency is USB. */
 513   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 514   1      
 515   1          switch (currentFreq)
 516   1          {
 517   2          case 0u:
 518   2              currentFreq = CY_IMO_FREQ_12MHZ;
 519   2              break;
 520   2      
 521   2          case 1u:
 522   2              currentFreq = CY_IMO_FREQ_6MHZ;
 523   2              break;
 524   2      
 525   2          case 2u:
 526   2              currentFreq = CY_IMO_FREQ_24MHZ;
 527   2              break;
 528   2      
 529   2          case 3u:
 530   2              currentFreq = CY_IMO_FREQ_3MHZ;
 531   2              break;
 532   2      
 533   2          case 4u:
 534   2              currentFreq = CY_IMO_FREQ_48MHZ;
 535   2              break;
 536   2      
 537   2          case 5u:
 538   2              currentFreq = CY_IMO_FREQ_62MHZ;
 539   2              break;
 540   2      
 541   2      #if(CY_PSOC5)
                  case 6u:
                      currentFreq = CY_IMO_FREQ_74MHZ;
                      break;
              #endif  /* (CY_PSOC5) */
 546   2      
 547   2          default:
 548   2              CYASSERT(0u != 0u);
 549   2              break;
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 10  

 550   2          }
 551   1      
 552   1          if (nextFreq >= currentFreq)
 553   1          {
 554   2              /* Set new trim first */
 555   2              CyIMO_SetTrimValue(freq);
 556   2          }
 557   1      
 558   1          /* Set usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 559   1          switch(freq)
 560   1          {
 561   2          case CY_IMO_FREQ_3MHZ:
 562   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 563   2                  CY_LIB_IMO_3MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 564   2              break;
 565   2      
 566   2          case CY_IMO_FREQ_6MHZ:
 567   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 568   2                  CY_LIB_IMO_6MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 569   2              break;
 570   2      
 571   2          case CY_IMO_FREQ_12MHZ:
 572   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 573   2                  CY_LIB_IMO_12MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 574   2              break;
 575   2      
 576   2          case CY_IMO_FREQ_24MHZ:
 577   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 578   2                  CY_LIB_IMO_24MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 579   2              break;
 580   2      
 581   2          case CY_IMO_FREQ_48MHZ:
 582   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 583   2                  CY_LIB_IMO_48MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 584   2              break;
 585   2      
 586   2          case CY_IMO_FREQ_62MHZ:
 587   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 588   2                  CY_LIB_IMO_62MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 589   2              break;
 590   2      
 591   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
                          CY_LIB_IMO_74MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
                      break;
              #endif  /* (CY_PSOC5) */
 597   2      
 598   2          case CY_IMO_FREQ_USB:
 599   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 600   2                  CY_LIB_IMO_24MHZ_VALUE) | CY_LIB_IMO_USBCLK_ON_SET;
 601   2              break;
 602   2      
 603   2          default:
 604   2              CYASSERT(0u != 0u);
 605   2              break;
 606   2          }
 607   1      
 608   1          /* Tu rn onIMO Doubler, if switching to CY_IMO_FREQ_USB */
 609   1          if (freq == CY_IMO_FREQ_USB)
 610   1          {
 611   2              CyIMO_EnableDoubler();
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 11  

 612   2          }
 613   1          else
 614   1          {
 615   2              CyIMO_DisableDoubler();
 616   2          }
 617   1      
 618   1          if (nextFreq < currentFreq)
 619   1          {
 620   2              /* Set the trim after setting frequency */
 621   2              CyIMO_SetTrimValue(freq);
 622   2          }
 623   1      }
 624          
 625          
 626          /*******************************************************************************
 627          * Function Name: CyIMO_SetSource
 628          ********************************************************************************
 629          *
 630          * Summary:
 631          *  Sets the source of the clock output from the IMO block.
 632          *
 633          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 634          *  Crystal or DSI input can be the source of the IMO output instead.
 635          *
 636          * Parameters:
 637          *   source: CY_IMO_SOURCE_DSI to set the DSI as source.
 638          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 639          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 640          *
 641          * Return:
 642          *  None
 643          *
 644          * Side Effects:
 645          *  If this function execution resulted in the CPU clock frequency increasing,
 646          *  then the number of clock cycles the cache will wait before it samples data
 647          *  coming back from the Flash must be adjusted by calling
 648          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 649          *  called if the CPU clock frequency is lowered in order to improve the CPU
 650          *  performance. See CyFlash_SetWaitCycles() description for more information.
 651          *
 652          *******************************************************************************/
 653          void CyIMO_SetSource(uint8 source) 
 654          {
 655   1          switch(source)
 656   1          {
 657   2          case CY_IMO_SOURCE_DSI:
 658   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 659   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 660   2              break;
 661   2      
 662   2          case CY_IMO_SOURCE_XTAL:
 663   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
 664   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 665   2              break;
 666   2      
 667   2          case CY_IMO_SOURCE_IMO:
 668   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
 669   2              break;
 670   2      
 671   2          default:
 672   2              /* Incorrect source value */
 673   2              CYASSERT(0u != 0u);
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 12  

 674   2              break;
 675   2          }
 676   1      }
 677          
 678          
 679          /*******************************************************************************
 680          * Function Name: CyIMO_EnableDoubler
 681          ********************************************************************************
 682          *
 683          * Summary:
 684          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 685          *  input to a 48 MHz output for use by the USB block.
 686          *
 687          * Parameters:
 688          *  None
 689          *
 690          * Return:
 691          *  None
 692          *
 693          *******************************************************************************/
 694          void CyIMO_EnableDoubler(void) 
 695          {
 696   1          /* Set FASTCLK_IMO_CR_PTR regigster's 4th bit */
 697   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 698   1      }
 699          
 700          
 701          /*******************************************************************************
 702          * Function Name: CyIMO_DisableDoubler
 703          ********************************************************************************
 704          *
 705          * Summary:
 706          *   Disables the IMO doubler.
 707          *
 708          * Parameters:
 709          *  None
 710          *
 711          * Return:
 712          *  None
 713          *
 714          *******************************************************************************/
 715          void CyIMO_DisableDoubler(void) 
 716          {
 717   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: CyMasterClk_SetSource
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  Sets the source of the master clock.
 727          *
 728          * Parameters:
 729          *   source: One of the four available Master clock sources.
 730          *     CY_MASTER_SOURCE_IMO
 731          *     CY_MASTER_SOURCE_PLL
 732          *     CY_MASTER_SOURCE_XTAL
 733          *     CY_MASTER_SOURCE_DSI
 734          *
 735          * Return:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 13  

 736          *  None
 737          *
 738          * Side Effects:
 739          *  The current source and the new source must both be running and stable before
 740          *  calling this function.
 741          *
 742          *  If this function execution resulted in the CPU clock frequency increasing,
 743          *  then the number of clock cycles the cache will wait before it samples data
 744          *  coming back from the Flash must be adjusted by calling
 745          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 746          *  called if the CPU clock frequency is lowered in order to improve the CPU
 747          *  performance. See CyFlash_SetWaitCycles() description for more information.
 748          *
 749          *******************************************************************************/
 750          void CyMasterClk_SetSource(uint8 source) 
 751          {
 752   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 753   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 754   1      }
 755          
 756          
 757          /*******************************************************************************
 758          * Function Name: CyMasterClk_SetDivider
 759          ********************************************************************************
 760          *
 761          * Summary:
 762          *  Sets the divider value used to generate Master Clock.
 763          *
 764          * Parameters:
 765          *  uint8 divider:
 766          *   The valid range is [0-255]. The clock will be divided by this value + 1.
 767          *   For example to divide this parameter by two should be set to 1.
 768          *
 769          * Return:
 770          *  None
 771          *
 772          * Side Effects:
 773          *  If this function execution resulted in the CPU clock frequency increasing,
 774          *  then the number of clock cycles the cache will wait before it samples data
 775          *  coming back from the Flash must be adjusted by calling
 776          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 777          *  called if the CPU clock frequency is lowered in order to improve the CPU
 778          *  performance. See CyFlash_SetWaitCycles() description for more information.
 779          *
 780          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 781          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 782          *  than the final/expected div-by-1 period.
 783          *
 784          *******************************************************************************/
 785          void CyMasterClk_SetDivider(uint8 divider) 
 786          {
 787   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 788   1      }
 789          
 790          
 791          /*******************************************************************************
 792          * Function Name: CyBusClk_Internal_SetDivider
 793          ********************************************************************************
 794          *
 795          * Summary:
 796          *  The function used by CyBusClk_SetDivider(). For internal use only.
 797          *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 14  

 798          * Parameters:
 799          *   divider: Valid range [0-65535].
 800          *   The clock will be divided by this value + 1.
 801          *   For example, to divide this parameter by two should be set to 1.
 802          *
 803          * Return:
 804          *  None
 805          *
 806          *******************************************************************************/
 807          static void CyBusClk_Internal_SetDivider(uint16 divider)
 808          {
 809   1          /* Mask bits to enable shadow loads  */
 810   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
 811   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 812   1      
 813   1          /* Enable mask bits to enable shadow loads */
 814   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 815   1      
 816   1          /* Update Shadow Divider Value Register with new divider */
 817   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 818   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 819   1      
 820   1      
 821   1          /***************************************************************************
 822   1          * Copy shadow value defined in Shadow Divider Value Register
 823   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 824   1          * dividers selected in Analog and Digital Clock Mask Registers
 825   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
 826   1          ***************************************************************************/
 827   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 828   1      }
 829          
 830          
 831          /*******************************************************************************
 832          * Function Name: CyBusClk_SetDivider
 833          ********************************************************************************
 834          *
 835          * Summary:
 836          *  Sets the divider value used to generate the Bus Clock.
 837          *
 838          * Parameters:
 839          *  divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 840          *  For example, to divide this parameter by two should be set to 1.
 841          *
 842          * Return:
 843          *  None
 844          *
 845          * Side Effects:
 846          *  If this function execution resulted in the CPU clock frequency increasing,
 847          *  then the number of clock cycles the cache will wait before it samples data
 848          *  coming back from the Flash must be adjusted by calling
 849          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 850          *  called if the CPU clock frequency is lowered in order to improve the CPU
 851          *  performance. See CyFlash_SetWaitCycles() description for more information.
 852          *
 853          *******************************************************************************/
 854          void CyBusClk_SetDivider(uint16 divider) 
 855          {
 856   1          uint8  masterClkDiv;
 857   1          uint16 busClkDiv;
 858   1          uint8 interruptState;
 859   1      
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 15  

 860   1          interruptState = CyEnterCriticalSection();
 861   1      
 862   1          /* Work around to set bus clock divider value */
 863   1          busClkDiv = (uint16)((uint16)CY_LIB_CLKDIST_BCFG_MSB_REG << 8u);
 864   1          busClkDiv |= CY_LIB_CLKDIST_BCFG_LSB_REG;
 865   1      
 866   1          if ((divider == 0u) || (busClkDiv == 0u))
 867   1          {
 868   2              /* Save away master clock divider value */
 869   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 870   2      
 871   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 872   2              {
 873   3                  /* Set master clock divider to 7 */
 874   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 875   3              }
 876   2      
 877   2              if (divider == 0u)
 878   2              {
 879   3                  /* Set SSS bit and divider register desired value */
 880   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 881   3                  CyBusClk_Internal_SetDivider(divider);
 882   3              }
 883   2              else
 884   2              {
 885   3                  CyBusClk_Internal_SetDivider(divider);
 886   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 887   3              }
 888   2      
 889   2              /* Restore master clock */
 890   2              CyMasterClk_SetDivider(masterClkDiv);
 891   2          }
 892   1          else
 893   1          {
 894   2              CyBusClk_Internal_SetDivider(divider);
 895   2          }
 896   1      
 897   1          CyExitCriticalSection(interruptState);
 898   1      }
 899          
 900          
 901          #if(CY_PSOC3)
 902          
 903              /*******************************************************************************
 904              * Function Name: CyCpuClk_SetDivider
 905              ********************************************************************************
 906              *
 907              * Summary:
 908              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 909              *  PSoC 3 parts.
 910              *
 911              * Parameters:
 912              *  divider: Valid range [0-15]. The clock will be divided by this value + 1.
 913              *  For example, to divide this parameter by two should be set to 1.
 914              *
 915              * Return:
 916              *  None
 917              *
 918              * Side Effects:
 919              *  If this function execution resulted in the CPU clock frequency increasing,
 920              *  then the number of clock cycles the cache will wait before it samples data
 921              *  coming back from the Flash must be adjusted by calling
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 16  

 922              *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 923              *  called if the CPU clock frequency is lowered in order to improve the CPU
 924              *  performance. See CyFlash_SetWaitCycles() description for more information.
 925              *
 926              *******************************************************************************/
 927              void CyCpuClk_SetDivider(uint8 divider) 
 928              {
 929   1                  CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & CY_LIB_CLKDIST_MSTR1_DIV_MASK) |
 930   1                                      ((uint8)(divider << CY_LIB_CLKDIST_DIV_POSITION));
 931   1          }
 932          
 933          #endif /* (CY_PSOC3) */
 934          
 935          
 936          /*******************************************************************************
 937          * Function Name: CyUsbClk_SetSource
 938          ********************************************************************************
 939          *
 940          * Summary:
 941          *  Sets the source of the USB clock.
 942          *
 943          * Parameters:
 944          *  source: One of the four available USB clock sources
 945          *    CY_LIB_USB_CLK_IMO2X     - IMO 2x
 946          *    CY_LIB_USB_CLK_IMO       - IMO
 947          *    CY_LIB_USB_CLK_PLL       - PLL
 948          *    CY_LIB_USB_CLK_DSI       - DSI
 949          *
 950          * Return:
 951          *  None
 952          *
 953          *******************************************************************************/
 954          void CyUsbClk_SetSource(uint8 source) 
 955          {
 956   1          CY_LIB_CLKDIST_UCFG_REG = (CY_LIB_CLKDIST_UCFG_REG & ((uint8)(~CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK))) |
 957   1                              (CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK & source);
 958   1      }
 959          
 960          
 961          /*******************************************************************************
 962          * Function Name: CyILO_Start1K
 963          ********************************************************************************
 964          *
 965          * Summary:
 966          *  Enables the ILO 1 KHz oscillator.
 967          *
 968          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
 969          *  selection in the Clock Editor. Therefore, this API is only needed if the
 970          *  oscillator was turned off manually.
 971          *
 972          * Parameters:
 973          *  None
 974          *
 975          * Return:
 976          *  None
 977          *
 978          *******************************************************************************/
 979          void CyILO_Start1K(void) 
 980          {
 981   1          /* Set bit 1 of ILO RS */
 982   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ;
 983   1      }
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 17  

 984          
 985          
 986          /*******************************************************************************
 987          * Function Name: CyILO_Stop1K
 988          ********************************************************************************
 989          *
 990          * Summary:
 991          *  Disables the ILO 1 KHz oscillator.
 992          *
 993          *  Note The ILO 1 KHz oscillator must be enabled if the Sleep or Hibernate low
 994          *  power mode APIs are expected to be used. For more information, refer to the
 995          *  Power Management section of this document.
 996          *
 997          * Parameters:
 998          *  None
 999          *
1000          * Return:
1001          *  None
1002          *
1003          * Side Effects:
1004          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
1005          *
1006          *******************************************************************************/
1007          void CyILO_Stop1K(void) 
1008          {
1009   1          /* Clear bit 1 of ILO RS */
1010   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ));
1011   1      }
1012          
1013          
1014          /*******************************************************************************
1015          * Function Name: CyILO_Start100K
1016          ********************************************************************************
1017          *
1018          * Summary:
1019          *  Enables the ILO 100 KHz oscillator.
1020          *
1021          * Parameters:
1022          *  None
1023          *
1024          * Return:
1025          *  None
1026          *
1027          *******************************************************************************/
1028          void CyILO_Start100K(void) 
1029          {
1030   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
1031   1      }
1032          
1033          
1034          /*******************************************************************************
1035          * Function Name: CyILO_Stop100K
1036          ********************************************************************************
1037          *
1038          * Summary:
1039          *  Disables the ILO 100 KHz oscillator.
1040          *
1041          * Parameters:
1042          *  None
1043          *
1044          * Return:
1045          *  None
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 18  

1046          *
1047          *******************************************************************************/
1048          void CyILO_Stop100K(void) 
1049          {
1050   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ));
1051   1      }
1052          
1053          
1054          /*******************************************************************************
1055          * Function Name: CyILO_Enable33K
1056          ********************************************************************************
1057          *
1058          * Summary:
1059          *  Enables the ILO 33 KHz divider.
1060          *
1061          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
1062          *  so it must also be running in order to generate the 33 KHz output.
1063          *
1064          * Parameters:
1065          *  None
1066          *
1067          * Return:
1068          *  None
1069          *
1070          *******************************************************************************/
1071          void CyILO_Enable33K(void) 
1072          {
1073   1          /* Set bit 5 of ILO RS */
1074   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ;
1075   1      }
1076          
1077          
1078          /*******************************************************************************
1079          * Function Name: CyILO_Disable33K
1080          ********************************************************************************
1081          *
1082          * Summary:
1083          *  Disables the ILO 33 KHz divider.
1084          *
1085          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
1086          *  API does not disable the 100 KHz clock.
1087          *
1088          * Parameters:
1089          *  None
1090          *
1091          * Return:
1092          *  None
1093          *
1094          *******************************************************************************/
1095          void CyILO_Disable33K(void) 
1096          {
1097   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ));
1098   1      }
1099          
1100          
1101          /*******************************************************************************
1102          * Function Name: CyILO_SetSource
1103          ********************************************************************************
1104          *
1105          * Summary:
1106          *  Sets the source of the clock output from the ILO block.
1107          *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 19  

1108          * Parameters:
1109          *  source: One of the three available ILO output sources
1110          *       Value        Define                Source
1111          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
1112          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
1113          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
1114          *
1115          * Return:
1116          *  None
1117          *
1118          *******************************************************************************/
1119          void CyILO_SetSource(uint8 source) 
1120          {
1121   1          CY_LIB_CLKDIST_CR_REG = (CY_LIB_CLKDIST_CR_REG & CY_ILO_SOURCE_BITS_CLEAR) |
1122   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
1123   1      }
1124          
1125          
1126          /*******************************************************************************
1127          * Function Name: CyILO_SetPowerMode
1128          ********************************************************************************
1129          *
1130          * Summary:
1131          *  Sets the power mode used by the ILO during power down. Allows for lower power
1132          *  down power usage resulting in a slower startup time.
1133          *
1134          * Parameters:
1135          *  uint8 mode
1136          *   CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
1137          *   CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
1138          *
1139          * Return:
1140          *   Prevous power mode state.
1141          *
1142          *******************************************************************************/
1143          uint8 CyILO_SetPowerMode(uint8 mode) 
1144          {
1145   1          uint8 state;
1146   1      
1147   1          /* Get current state. */
1148   1          state = CY_LIB_SLOWCLK_ILO_CR0_REG;
1149   1      
1150   1          /* Set the oscillator power mode. */
1151   1          if(mode != CY_ILO_FAST_START)
1152   1          {
1153   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state | CY_ILO_CONTROL_PD_MODE);
1154   2          }
1155   1          else
1156   1          {
1157   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state & ((uint8)(~CY_ILO_CONTROL_PD_MODE)));
1158   2          }
1159   1      
1160   1          /* Return old mode. */
1161   1          return ((state & CY_ILO_CONTROL_PD_MODE) >> CY_ILO_CONTROL_PD_POSITION);
1162   1      }
1163          
1164          
1165          /*******************************************************************************
1166          * Function Name: CyXTAL_32KHZ_Start
1167          ********************************************************************************
1168          *
1169          * Summary:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 20  

1170          *  Enables the 32 KHz Crystal Oscillator.
1171          *
1172          * Parameters:
1173          *  None
1174          *
1175          * Return:
1176          *  None
1177          *
1178          *******************************************************************************/
1179          void CyXTAL_32KHZ_Start(void) 
1180          {
1181   1          volatile uint16 i;
1182   1      
1183   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1184   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1185   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1186   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1187   1      
1188   1          #if(CY_PSOC3)
1189   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1190   1          #endif  /* (CY_PSOC3) */
1191   1      
1192   1          /* Enable operation of 32K Crystal Oscillator */
1193   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1194   1      
1195   1          for (i = 1000u; i > 0u; i--)
1196   1          {
1197   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1198   2              {
1199   3                  /* Ready - switch to high power mode */
1200   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1201   3      
1202   3                  break;
1203   3              }
1204   2              CyDelayUs(1u);
1205   2          }
1206   1      }
1207          
1208          
1209          /*******************************************************************************
1210          * Function Name: CyXTAL_32KHZ_Stop
1211          ********************************************************************************
1212          *
1213          * Summary:
1214          *  Disables the 32KHz Crystal Oscillator.
1215          *
1216          * Parameters:
1217          *  None
1218          *
1219          * Return:
1220          *  None
1221          *
1222          *******************************************************************************/
1223          void CyXTAL_32KHZ_Stop(void) 
1224          {
1225   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
1226   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
1227   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1228   1                                   CY_CLK_XTAL32_CFG_LP_DEFAULT;
1229   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1230   1      
1231   1          #if(CY_PSOC3)
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 21  

1232   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1233   1          #endif  /* (CY_PSOC3) */
1234   1      }
1235          
1236          
1237          /*******************************************************************************
1238          * Function Name: CyXTAL_32KHZ_ReadStatus
1239          ********************************************************************************
1240          *
1241          * Summary:
1242          *  Returns status of the 32 KHz oscillator.
1243          *
1244          * Parameters:
1245          *  None
1246          *
1247          * Return:
1248          *  Value     Define                    Source
1249          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1250          *                                       1: Stable
1251          *                                       0: Not stable
1252          *
1253          *******************************************************************************/
1254          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1255          {
1256   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
1257   1      }
1258          
1259          
1260          /*******************************************************************************
1261          * Function Name: CyXTAL_32KHZ_SetPowerMode
1262          ********************************************************************************
1263          *
1264          * Summary:
1265          *  Sets the power mode for the 32 KHz oscillator used during the sleep mode.
1266          *  Allows for lower power during sleep when there are fewer sources of noise.
1267          *  During the active mode the oscillator is always run in the high power mode.
1268          *
1269          * Parameters:
1270          *  uint8 mode
1271          *       0: High power mode
1272          *       1: Low power mode during sleep
1273          *
1274          * Return:
1275          *  Previous power mode.
1276          *
1277          *******************************************************************************/
1278          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1279          {
1280   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1281   1      
1282   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1283   1      
1284   1          if(1u == mode)
1285   1          {
1286   2              /* Low power mode during Sleep */
1287   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
1288   2              CyDelayUs(10u);
1289   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1290   2                                      CY_CLK_XTAL32_CFG_LP_LOWPOWER;
1291   2              CyDelayUs(20u);
1292   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
1293   2          }
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 22  

1294   1          else
1295   1          {
1296   2              /* High power mode */
1297   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1298   2              CyDelayUs(10u);
1299   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1300   2                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1301   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1302   2          }
1303   1      
1304   1          return(state);
1305   1      }
1306          
1307          
1308          /*******************************************************************************
1309          * Function Name: CyXTAL_Start
1310          ********************************************************************************
1311          *
1312          * Summary:
1313          *  Enables the megahertz crystal.
1314          *
1315          *  PSoC 3:
1316          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1317          *  number of milliseconds specified by the wait parameter has expired.
1318          *
1319          * Parameters:
1320          *   wait: Valid range [0-255].
1321          *   This is the timeout value in milliseconds.
1322          *   The appropriate value is crystal specific.
1323          *
1324          * Return:
1325          *   CYRET_SUCCESS - Completed successfully
1326          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1327          *
1328          * Side Effects and Restrictions:
1329          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1330          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
1331          *  of this function and then restored.
1332          *
1333          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1334          *  ILO for the period of this function. No changes to the setup of the ILO,
1335          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1336          *  by interrupt routines during the period of this function.
1337          *
1338          *  The current operation of the ILO, Central Timewheel and Once Per Second
1339          *  interrupt are maintained during the operation of this function provided the
1340          *  reading of the Power Manager Interrupt Status Register is only done using the
1341          *  CyPmReadStatus() function.
1342          *
1343          *******************************************************************************/
1344          cystatus CyXTAL_Start(uint8 wait) 
1345          {
1346   1          cystatus status = CYRET_SUCCESS;
1347   1          volatile uint8  timeout = wait;
1348   1          volatile uint8 count;
1349   1          uint8 iloEnableState;
1350   1          uint8 pmTwCfg0Tmp;
1351   1          uint8 pmTwCfg2Tmp;
1352   1      
1353   1      
1354   1          /* Enables MHz crystal oscillator circuit  */
1355   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 23  

1356   1      
1357   1      
1358   1          if(wait > 0u)
1359   1          {
1360   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1361   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG;
1362   2              pmTwCfg0Tmp = CY_LIB_PM_TW_CFG0_REG;
1363   2              pmTwCfg2Tmp = CY_LIB_PM_TW_CFG2_REG;
1364   2      
1365   2              /* Set 250 us interval */
1366   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1367   2              status = CYRET_TIMEOUT;
1368   2      
1369   2      
1370   2              for( ; timeout > 0u; timeout--)
1371   2              {
1372   3                  /* Read XERR bit to clear it */
1373   3                  (void) CY_CLK_XMHZ_CSR_REG;
1374   3      
1375   3                  /* Wait for 1 millisecond - 4 x 250 us */
1376   3                  for(count = 4u; count > 0u; count--)
1377   3                  {
1378   4                      while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
1379   4                      {
1380   5                          /* Wait for FTW interrupt event */
1381   5                      }
1382   4                  }
1383   3      
1384   3      
1385   3                  /*******************************************************************
1386   3                  * High output indicates an oscillator failure.
1387   3                  * Only can be used after a start-up interval (1 ms) is completed.
1388   3                  *******************************************************************/
1389   3                  if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1390   3                  {
1391   4                      status = CYRET_SUCCESS;
1392   4                      break;
1393   4                  }
1394   3              }
1395   2      
1396   2      
1397   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1398   2              if(0u == (iloEnableState & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ))
1399   2              {
1400   3                  CyILO_Stop100K();
1401   3              }
1402   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1403   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1404   2          }
1405   1      
1406   1          return(status);
1407   1      }
1408          
1409          
1410          /*******************************************************************************
1411          * Function Name: CyXTAL_Stop
1412          ********************************************************************************
1413          *
1414          * Summary:
1415          *  Disables the megahertz crystal oscillator.
1416          *
1417          * Parameters:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 24  

1418          *  None
1419          *
1420          * Return:
1421          *  None
1422          *
1423          *******************************************************************************/
1424          void CyXTAL_Stop(void) 
1425          {
1426   1          /* Disable oscillator. */
1427   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1428   1      }
1429          
1430          
1431          /*******************************************************************************
1432          * Function Name: CyXTAL_EnableErrStatus
1433          ********************************************************************************
1434          *
1435          * Summary:
1436          *  Enables the generation of the XERR status bit for the megahertz crystal.
1437          *  This function is not available for PSoC5.
1438          *
1439          * Parameters:
1440          *  None
1441          *
1442          * Return:
1443          *  None
1444          *
1445          *******************************************************************************/
1446          void CyXTAL_EnableErrStatus(void) 
1447          {
1448   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1449   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1450   1      }
1451          
1452          
1453          /*******************************************************************************
1454          * Function Name: CyXTAL_DisableErrStatus
1455          ********************************************************************************
1456          *
1457          * Summary:
1458          *  Disables the generation of the XERR status bit for the megahertz crystal.
1459          *  This function is not available for PSoC5.
1460          *
1461          * Parameters:
1462          *  None
1463          *
1464          * Return:
1465          *  None
1466          *
1467          *******************************************************************************/
1468          void CyXTAL_DisableErrStatus(void) 
1469          {
1470   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1471   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1472   1      }
1473          
1474          
1475          /*******************************************************************************
1476          * Function Name: CyXTAL_ReadStatus
1477          ********************************************************************************
1478          *
1479          * Summary:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 25  

1480          *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1481          *  sticky, clear on read. This function is not available for PSoC5.
1482          *
1483          * Parameters:
1484          *  None
1485          *
1486          * Return:
1487          *   Status
1488          *    0: No error
1489          *    1: Error
1490          *
1491          *******************************************************************************/
1492          uint8 CyXTAL_ReadStatus(void) 
1493          {
1494   1          /***************************************************************************
1495   1          * High output indicates an oscillator failure. Only use this after a start-up
1496   1          * interval is completed. This can be used for the status and failure recovery.
1497   1          ***************************************************************************/
1498   1          return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1499   1      }
1500          
1501          
1502          /*******************************************************************************
1503          * Function Name: CyXTAL_EnableFaultRecovery
1504          ********************************************************************************
1505          *
1506          * Summary:
1507          *  Enables the fault recovery circuit which will switch to the IMO in the case
1508          *  of a fault in the megahertz crystal circuit. The crystal must be up and
1509          *  running with the XERR bit at 0, before calling this function to prevent
1510          *  an immediate fault switchover. This function is not available for PSoC5.
1511          *
1512          * Parameters:
1513          *  None
1514          *
1515          * Return:
1516          *  None
1517          *
1518          *******************************************************************************/
1519          void CyXTAL_EnableFaultRecovery(void) 
1520          {
1521   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1522   1      }
1523          
1524          
1525          /*******************************************************************************
1526          * Function Name: CyXTAL_DisableFaultRecovery
1527          ********************************************************************************
1528          *
1529          * Summary:
1530          *  Disables the fault recovery circuit which will switch to the IMO in the case
1531          *  of a fault in the megahertz crystal circuit. This function is not available
1532          *  for PSoC5.
1533          *
1534          * Parameters:
1535          *  None
1536          *
1537          * Return:
1538          *  None
1539          *
1540          *******************************************************************************/
1541          void CyXTAL_DisableFaultRecovery(void) 
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 26  

1542          {
1543   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1544   1      }
1545          
1546          
1547          /*******************************************************************************
1548          * Function Name: CyXTAL_SetStartup
1549          ********************************************************************************
1550          *
1551          * Summary:
1552          *  Sets the startup settings for the crystal. The logic model outputs a
1553          *  frequency (setting + 4) MHz when enabled.
1554          *
1555          *  This is artificial as the actual frequency is determined by an attached
1556          *  external crystal.
1557          *
1558          * Parameters:
1559          *  setting: Valid range [0-31].
1560          *   The value is dependent on the frequency and quality of the crystal being
1561          *   used. Refer to the device TRM and datasheet for more information.
1562          *
1563          * Return:
1564          *  None
1565          *
1566          *******************************************************************************/
1567          void CyXTAL_SetStartup(uint8 setting) 
1568          {
1569   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1570   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1571   1      }
1572          
1573          
1574          
1575          /*******************************************************************************
1576          * Function Name: CyXTAL_SetFbVoltage
1577          ********************************************************************************
1578          *
1579          * Summary:
1580          *  Sets the feedback reference voltage to use for the crystal circuit.
1581          *  This function is only available for PSoC3 and PSoC 5LP.
1582          *
1583          * Parameters:
1584          *  setting: Valid range [0-15].
1585          *  Refer to the device TRM and datasheet for more information.
1586          *
1587          * Return:
1588          *  None
1589          *
1590          *******************************************************************************/
1591          void CyXTAL_SetFbVoltage(uint8 setting) 
1592          {
1593   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1594   1                                  (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1595   1      }
1596          
1597          
1598          /*******************************************************************************
1599          * Function Name: CyXTAL_SetWdVoltage
1600          ********************************************************************************
1601          *
1602          * Summary:
1603          *  Sets the reference voltage used by the watchdog to detect a failure in the
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 27  

1604          *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1605          *
1606          * Parameters:
1607          *  setting: Valid range [0-7].
1608          *  Refer to the device TRM and datasheet for more information.
1609          *
1610          * Return:
1611          *  None
1612          *
1613          *******************************************************************************/
1614          void CyXTAL_SetWdVoltage(uint8 setting) 
1615          {
1616   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1617   1                                  (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1618   1      }
1619          
1620          
1621          /*******************************************************************************
1622          * Function Name: CyHalt
1623          ********************************************************************************
1624          *
1625          * Summary:
1626          *  Halts the CPU.
1627          *
1628          * Parameters:
1629          *  uint8 reason: Value to be used during debugging.
1630          *
1631          * Return:
1632          *  None
1633          *
1634          *******************************************************************************/
1635          void CyHalt(uint8 reason) CYREENTRANT
1636          {
1637   1          if(0u != reason)
1638   1          {
1639   2              /* To remove unreferenced local variable warning */
1640   2          }
1641   1      
1642   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__) || defined (__ICCARM__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1647   1              CYDEV_HALT_CPU;
1648   1          #endif  /* (__ARMCC_VERSION) */
1649   1      }
1650          
1651          
1652          /*******************************************************************************
1653          * Function Name: CySoftwareReset
1654          ********************************************************************************
1655          *
1656          * Summary:
1657          *  Forces a device software reset.
1658          *
1659          * Parameters:
1660          *  None
1661          *
1662          * Return:
1663          *  None
1664          *
1665          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 28  

1666          void CySoftwareReset(void) 
1667          {
1668   1          CY_LIB_RESET_CR2_REG |= CY_LIB_RESET_CR2_RESET;
1669   1      }
1670          
1671          
1672          /*******************************************************************************
1673          * Function Name: CyDelay
1674          ********************************************************************************
1675          *
1676          * Summary:
1677          *  Blocks for milliseconds.
1678          *
1679          *  Note:
1680          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1681          *  the instruction cache is disabled on PSoC5, CyDelay will be two times larger.
1682          *  For example, with instruction cache disabled CyDelay(100) would result in
1683          *  about 200 ms delay instead of 100 ms.
1684          *
1685          * Parameters:
1686          *  milliseconds: number of milliseconds to delay.
1687          *
1688          * Return:
1689          *   None
1690          *
1691          *******************************************************************************/
1692          void CyDelay(uint32 milliseconds) CYREENTRANT
1693          {
1694   1          while (milliseconds > 32768u)
1695   1          {
1696   2              /***********************************************************************
1697   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1698   2              * overflows at about 42 seconds.
1699   2              ***********************************************************************/
1700   2              CyDelayCycles(cydelay_32k_ms);
1701   2              milliseconds = ((uint32)(milliseconds - 32768u));
1702   2          }
1703   1      
1704   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1705   1      }
1706          
1707          
1708          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
                  /*******************************************************************************
                  * Function Name: CyDelayUs
                  ********************************************************************************
                  *
                  * Summary:
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
                  *   in about 200us delay instead of 100us.
                  *
                  * Parameters:
                  *  uint16 microseconds: number of microseconds to delay.
                  *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 29  

                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When the instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with the instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1747          
1748          
1749          /*******************************************************************************
1750          * Function Name: CyDelayFreq
1751          ********************************************************************************
1752          *
1753          * Summary:
1754          *  Sets the clock frequency for CyDelay.
1755          *
1756          * Parameters:
1757          *  freq: The frequency of the bus clock in Hertz.
1758          *
1759          * Return:
1760          *  None
1761          *
1762          *******************************************************************************/
1763          void CyDelayFreq(uint32 freq) CYREENTRANT
1764          {
1765   1          if (freq != 0u)
1766   1          {
1767   2              cydelay_freq_hz = freq;
1768   2          }
1769   1          else
1770   1          {
1771   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1772   2          }
1773   1      
1774   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1775   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1776   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1777   1      }
1778          
1779          
1780          /*******************************************************************************
1781          * Function Name: CyWdtStart
1782          ********************************************************************************
1783          *
1784          * Summary:
1785          *  Enables the watchdog timer.
1786          *
1787          *  The timer is configured for the specified count interval, the central
1788          *  timewheel is cleared, the setting for the low power mode is configured and
1789          *  the watchdog timer is enabled.
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 30  

1790          *
1791          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1792          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1793          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1794          *  timer occur. The CTW is free running, so this will occur after between 2 and
1795          *  3 timer periods elapse.
1796          *
1797          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1798          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1799          *  set to be greater than the sleep wakeup period, then feed the dog on each
1800          *  wakeup from Sleep.
1801          *
1802          * Parameters:
1803          *  ticks: One of the four available timer periods. Once WDT enabled, the
1804             interval cannot be changed.
1805          *         CYWDT_2_TICKS     -     4 - 6     ms
1806          *         CYWDT_16_TICKS    -    32 - 48    ms
1807          *         CYWDT_128_TICKS   -   256 - 384   ms
1808          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1809          *
1810          *  lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1811          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1812          *
1813          *          CYWDT_LPMODE_NOCHANGE - No Change
1814          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1815          *                                 mode
1816          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1817          *
1818          * Return:
1819          *  None
1820          *
1821          * Side Effects:
1822          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1823          *  ILO 1 kHz could break the active WDT functionality.
1824          *
1825          *******************************************************************************/
1826          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1827          {
1828   1          /* Set WDT interval */
1829   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1830   1      
1831   1          /* Reset CTW to ensure that first watchdog period is full */
1832   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1833   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1834   1      
1835   1          /* Setting low power mode */
1836   1          CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1837   1                             (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1838   1      
1839   1          /* Enables watchdog reset */
1840   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1841   1      }
1842          
1843          
1844          /*******************************************************************************
1845          * Function Name: CyWdtClear
1846          ********************************************************************************
1847          *
1848          * Summary:
1849          *  Clears (feeds) the watchdog timer.
1850          *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 31  

1851          * Parameters:
1852          *  None
1853          *
1854          * Return:
1855          *  None
1856          *
1857          *******************************************************************************/
1858          void CyWdtClear(void) 
1859          {
1860   1          CY_WDT_CR_REG = CY_WDT_CR_FEED;
1861   1      }
1862          
1863          
1864          
1865          /*******************************************************************************
1866          * Function Name: CyVdLvDigitEnable
1867          ********************************************************************************
1868          *
1869          * Summary:
1870          *  Sets the voltage trip level, enables the output of the digital low-voltage
1871          *  monitor, and optionally configures voltage monitor to reset device upon the
1872          *  low-voltage event instead of generating an interrupt.
1873          *
1874          *  Note The associated interrupt enable/disable state is not changed by the
1875          *  function. The Interrupt components API should be used to register the
1876          *  interrupt service routine and to enable/disable associated interrupt.
1877          *
1878          * Parameters:
1879          *  reset: Enables device reset on digital low-voltage event:
1880          *   Zero - Interrupt on digital low-voltage event
1881          *   Non-zero - Reset on digital low-voltage event
1882          *
1883          *  threshold: Sets the trip point of the digital low-voltage monitoring circuit
1884          *   in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1885          *   (0x0F). For example, the trip point is set to 1.80 V when the threshold
1886          *   parameter value is 0x04. Refer to the device TRM for the exact trip voltage
1887          *   values.
1888          *
1889          * Return:
1890          *  None
1891          *
1892          * Side Effects and Restrictions:
1893          *  The voltage resets are momentary. When a voltage reset (analog/digital
1894          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1895          *  registers are restored to their default values. This means that the voltage
1896          *  monitor circuit is no longer enabled and the device exits reset. If the
1897          *  supply is below the trip level and firmware enables the voltage reset
1898          *  functionality, the device will reset again. This will continue as long as the
1899          *  supply is below the trip level or as long as the user enables the reset
1900          *  functionality of the voltage monitor functionality.
1901          *
1902          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1903          *  are cleared. This means that analog low-voltage, digital low-voltage and
1904          *  analog high-voltage status bits are not persistent across any voltage reset.
1905          *
1906          *******************************************************************************/
1907          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
1908          {
1909   1          uint32 intRegTmp;
1910   1          uint8 interruptState;
1911   1      
1912   1          interruptState = CyEnterCriticalSection();
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 32  

1913   1      
1914   1          /* Store interrupt enable state */
1915   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1916   1      
1917   1          /* Disable VD interrupt (write 1) to protect against glitches */
1918   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1919   1      
1920   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1921   1      
1922   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1923   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
1924   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
1925   1      
1926   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
1927   1          CyDelayUs(1u);
1928   1      
1929   1          (void) CyVdStickyStatus(CY_VD_LVID);
1930   1      
1931   1          if(0u != reset)
1932   1          {
1933   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1934   2          }
1935   1          else
1936   1          {
1937   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1938   2          }
1939   1      
1940   1          /* Clear pending interrupt */
1941   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1942   1      
1943   1          /* Restore interrupt enable state */
1944   1          CY_INT_ENABLE_REG = intRegTmp;
1945   1      
1946   1          CyExitCriticalSection(interruptState);
1947   1      }
1948          
1949          
1950          /*******************************************************************************
1951          * Function Name: CyVdLvAnalogEnable
1952          ********************************************************************************
1953          *
1954          * Summary:
1955          *  Sets the voltage trip level, enables the output of the analog low-voltage
1956          *  monitor, and optionally configures voltage monitor to reset device upon the
1957          *  low-voltage event instead of generating an interrupt.
1958          *
1959          *  Note The associated interrupt enable/disable state is not changed by the
1960          *  function. The Interrupt components API should be used to register the
1961          *  interrupt service routine and to enable/disable associated interrupt.
1962          *
1963          * Parameters:
1964          *  reset: Enables device reset on analog low-voltage event:
1965          *  Zero - Interrupt on analog low-voltage event
1966          *  Non-zero - Reset on analog low-voltage event
1967          *
1968          *  threshold: Sets the trip point of the analog low-voltage monitoring circuit
1969          *  in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1970          *  (0x0F). For example, the trip point is set to 1.80 V when value of the
1971          *  threshold parameter is 0x04. Please refer to the device TRM for the exact
1972          *  trip voltage values.
1973          *
1974          * Return:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 33  

1975          *  None
1976          *
1977          * Side Effects and Restrictions:
1978          *  The voltage resets are momentary. When a voltage reset (analog/digital
1979          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1980          *  registers are restored to their default values. This means that the voltage
1981          *  monitor circuit is no longer enabled and the device exits reset. If the
1982          *  supply is below the trip level and firmware enables the voltage reset
1983          *  functionality, the device will reset again. This will continue as long as
1984          *  the supply is below the trip level or as long as the user enables the reset
1985          *  functionality of the voltage monitor functionality.
1986          *
1987          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1988          *  are cleared. This means that analog low-voltage, digital low-voltage and
1989          *  analog high-voltage status bits are not persistent across any voltage reset.
1990          *
1991          *******************************************************************************/
1992          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
1993          {
1994   1          uint32 intRegTmp;
1995   1          uint8 interruptState;
1996   1      
1997   1          interruptState = CyEnterCriticalSection();
1998   1      
1999   1          /* Store interrupt enable state */
2000   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
2001   1      
2002   1          /* Disable VD interrupt (write 1) to protect against glitches */
2003   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
2004   1      
2005   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2006   1      
2007   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
2008   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
2009   1      
2010   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
2011   1          CyDelayUs(1u);
2012   1      
2013   1          (void) CyVdStickyStatus(CY_VD_LVIA);
2014   1      
2015   1          if(0u != reset)
2016   1          {
2017   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
2018   2          }
2019   1          else
2020   1          {
2021   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2022   2          }
2023   1      
2024   1          /* Clear pending interrupt */
2025   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
2026   1      
2027   1          /* Restore interrupt enable state */
2028   1          CY_INT_ENABLE_REG = intRegTmp;
2029   1      
2030   1          CyExitCriticalSection(interruptState);
2031   1      }
2032          
2033          
2034          /*******************************************************************************
2035          * Function Name: CyVdLvDigitDisable
2036          ********************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 34  

2037          *
2038          * Summary:
2039          *  Disables the digital low-voltage monitor, turns off device reset upon the
2040          *  digital low-voltage event, and clears the associated persistent status bit.
2041          *
2042          *  Note The associated interrupt enable/disable state is not changed by the
2043          *  function. The pending interrupt status is not cleared. The Interrupt
2044          *  components API should be used to manipulate with the associated interrupts.
2045          *
2046          * Parameters:
2047          *  None
2048          *
2049          * Return:
2050          *  None
2051          *
2052          *******************************************************************************/
2053          void CyVdLvDigitDisable(void) 
2054          {
2055   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
2056   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
2057   1          (void) CyVdStickyStatus(CY_VD_LVID);
2058   1      
2059   1          while(0u != (CyVdStickyStatus(CY_VD_LVID) & CY_VD_LVID))
2060   1          {
2061   2      
2062   2          }
2063   1      }
2064          
2065          
2066          /*******************************************************************************
2067          * Function Name: CyVdLvAnalogDisable
2068          ********************************************************************************
2069          *
2070          * Summary:
2071          *  Disables the analog low-voltage monitor, turns off device reset upon the
2072          *  analog low-voltage event, and clears the associated persistent status bit.
2073          *
2074          *  Note The associated interrupt enable/disable state is not changed by the
2075          *  function. The pending interrupt status is not cleared. The Interrupt
2076          *  components API should be used to manipulate with the associated interrupts.
2077          *
2078          * Parameters:
2079          *  None
2080          *
2081          * Return:
2082          *  None
2083          *
2084          *******************************************************************************/
2085          void CyVdLvAnalogDisable(void) 
2086          {
2087   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
2088   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2089   1          while(0u != (CyVdStickyStatus(CY_VD_LVIA) & CY_VD_LVIA))
2090   1          {
2091   2      
2092   2          }
2093   1      }
2094          
2095          
2096          /*******************************************************************************
2097          * Function Name: CyVdHvAnalogEnable
2098          ********************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 35  

2099          *
2100          * Summary:
2101          *  Enables the output of the analog high-voltage monitor and sets 5.75 V
2102          *  threshold detection for Vdda.
2103          *
2104          *  Note The associated interrupt enable/disable state is not changed by the
2105          *  function. The Interrupt components API should be used to register the
2106          *  interrupt service routine and to enable/disable associated interrupt.
2107          *
2108          * Parameters:
2109          *  None
2110          *
2111          * Return:
2112          *  None
2113          *
2114          *******************************************************************************/
2115          void CyVdHvAnalogEnable(void) 
2116          {
2117   1          uint32 intRegTmp;
2118   1          uint8 interruptState;
2119   1      
2120   1          interruptState = CyEnterCriticalSection();
2121   1      
2122   1          /* Store interrupt enable state */
2123   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
2124   1      
2125   1          /* Disable VD interrupt (write 1) to protect against glitches */
2126   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
2127   1      
2128   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2129   1      
2130   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
2131   1      
2132   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling (ID # 127412)  */
2133   1          CyDelayUs(1u);
2134   1      
2135   1          (void) CyVdStickyStatus(CY_VD_HVIA);
2136   1      
2137   1          /* Clear pending interrupt */
2138   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
2139   1      
2140   1          /* Restore interrupt enable state */
2141   1          CY_INT_ENABLE_REG = intRegTmp;
2142   1      
2143   1          CyExitCriticalSection(interruptState);
2144   1      }
2145          
2146          
2147          /*******************************************************************************
2148          * Function Name: CyVdHvAnalogDisable
2149          ********************************************************************************
2150          *
2151          * Summary:
2152          *  Disables the analog high-voltage monitor and clears the associated persistent
2153          *  status bit.
2154          *
2155          *  Note The associated interrupt enable/disable state is not changed by the
2156          *  function. The pending interrupt status is not cleared. The Interrupt
2157          *  components API should be used to manipulate with the associated interrupts.
2158          *
2159          * Parameters:
2160          *  None
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 36  

2161          *
2162          * Return:
2163          *  None
2164          *
2165          *******************************************************************************/
2166          void CyVdHvAnalogDisable(void) 
2167          {
2168   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
2169   1          while(0u != (CyVdStickyStatus(CY_VD_HVIA) & CY_VD_HVIA))
2170   1          {
2171   2      
2172   2          }
2173   1      }
2174          
2175          
2176          /*******************************************************************************
2177          * Function Name: CyVdStickyStatus
2178          ********************************************************************************
2179          *
2180          * Summary:
2181          *  Reads and clears the voltage detection status bits in the RESET_SR0 register.
2182          *  The bits are set to 1 by the voltage monitor circuit when the supply is
2183          *  outside the detectors trip point. They stay set to 1 until they are read or
2184          *  a POR / LVI / PRES reset occurs. This function uses a shadow register, so
2185          *  only the bits passed in the parameter will be cleared in the shadow register.
2186          *
2187          * Parameters:
2188          *  mask: Bits in the RESET_SR0 shadow register to clear and return.
2189          *   Define                  Definition
2190          *   CY_VD_LVID            Persistent status of digital LVI.
2191          *   CY_VD_LVIA            Persistent status of analog LVI.
2192          *   CY_VD_HVIA            Persistent status of analog HVI.
2193          *
2194          * Return:
2195          *  Status. Same enumerated bit values as used for the mask parameter. A zero is
2196          *  returned for bits not used in the mask parameter.
2197          *
2198          * Side Effects and Restrictions:
2199          *  When an LVI reset occurs, the RESET_SR0 status registers are cleared. This
2200          *  means that the voltage detection status bits are not persistent across an LVI
2201          *  reset and cannot be used to determine a reset source.
2202          *
2203          *******************************************************************************/
2204          uint8 CyVdStickyStatus(uint8 mask) 
2205          {
2206   1          static uint8 interruptStatus;
2207   1          uint8 interruptState;
2208   1          uint8 tmpStatus;
2209   1      
2210   1          interruptState = CyEnterCriticalSection();
2211   1      
2212   1          interruptStatus |= CY_VD_PERSISTENT_STATUS_REG;
2213   1          tmpStatus = interruptStatus & (uint8)(CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
2214   1          interruptStatus &= ((uint8)(~mask));
2215   1      
2216   1          CyExitCriticalSection(interruptState);
2217   1      
2218   1          return(tmpStatus);
2219   1      }
2220          
2221          
2222          /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 37  

2223          * Function Name: CyVdRealTimeStatus
2224          ********************************************************************************
2225          *
2226          * Summary:
2227          *  Reads the real-time voltage detection status bits in the RESET_SR2 register.
2228          *  The bits are set to 1 by the voltage monitor circuit when the supply is
2229          *  outside the detectors trip point, and set to 0 when the supply is inside the
2230          *  trip point.
2231          *
2232          * Parameters:
2233          *  None
2234          *
2235          * Return:
2236          *  Status of the LVID, LVIA, and HVIA bits in the RESET_SR2 register.
2237          *   Define                  Definition
2238          *   CY_VD_LVID            Real-time status of digital LVI.
2239          *   CY_VD_LVIA            Real-time status of analog LVI.
2240          *   CY_VD_HVIA            Real-time status of analog HVI.
2241          *
2242          * Side Effects and Restrictions:
2243          *  When an LVI reset occurs, the RESET_SR2 status registers are cleared. This
2244          *  means that the voltage detection status bits are not persistent across an LVI
2245          *  reset and cannot be used to determine a reset source.
2246          *
2247          *******************************************************************************/
2248          uint8 CyVdRealTimeStatus(void) 
2249          {
2250   1          uint8 interruptState;
2251   1          uint8 vdFlagsState;
2252   1      
2253   1          interruptState = CyEnterCriticalSection();
2254   1          vdFlagsState = CY_VD_RT_STATUS_REG & (CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
2255   1          CyExitCriticalSection(interruptState);
2256   1      
2257   1          return(vdFlagsState);
2258   1      }
2259          
2260          
2261          /*******************************************************************************
2262          * Function Name: CyDisableInts
2263          ********************************************************************************
2264          *
2265          * Summary:
2266          *  Disables the interrupt enable for each interrupt.
2267          *
2268          * Parameters:
2269          *  None
2270          *
2271          * Return:
2272          *  32 bit mask of previously enabled interrupts.
2273          *
2274          *******************************************************************************/
2275          uint32 CyDisableInts(void) 
2276          {
2277   1          uint32 intState;
2278   1          uint8 interruptState;
2279   1      
2280   1          interruptState = CyEnterCriticalSection();
2281   1      
2282   1          #if(CY_PSOC3)
2283   1      
2284   1              /* Get the current interrupt state. */
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 38  

2285   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
2286   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
2287   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
2288   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
2289   1      
2290   1      
2291   1              /* Disable all of the interrupts. */
2292   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
2293   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
2294   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
2295   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
2296   1      
2297   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2306   1      
2307   1          CyExitCriticalSection(interruptState);
2308   1      
2309   1          return (intState);
2310   1      }
2311          
2312          
2313          /*******************************************************************************
2314          * Function Name: CyEnableInts
2315          ********************************************************************************
2316          *
2317          * Summary:
2318          *  Enables interrupts to a given state.
2319          *
2320          * Parameters:
2321          *  uint32 mask: 32 bit mask of interrupts to enable.
2322          *
2323          * Return:
2324          *  None
2325          *
2326          *******************************************************************************/
2327          void CyEnableInts(uint32 mask) 
2328          {
2329   1      
2330   1          uint8 interruptState;
2331   1      
2332   1          interruptState = CyEnterCriticalSection();
2333   1      
2334   1          #if(CY_PSOC3)
2335   1      
2336   1              /* Set interrupts as enabled. */
2337   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2338   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2339   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2340   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
2341   1      
2342   1          #else
              
                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
              
                  #endif /* (CY_PSOC3) */
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 39  

2347   1      
2348   1          CyExitCriticalSection(interruptState);
2349   1      
2350   1      }
2351          
2352          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ********************************************************************************
                  * Summary:
                  *  Call this API after a flash row erase/write operation to invalidate or flush
                  *  any of that particular flash region content already present in the cache.
                  *  After a cache flush operation, any access to that flash region after the
                  *  erase/write operation would reload the cache with the modified data from the
                  *  flash region. If the flash region update involves multiple flash row write
                  *  operations, then the flushing of the cache can be done once at the end of
                  *  the operation as long as the flash data would not be accessed in the middle
                  *  of the multiple row update process. Else, flush the cache after every flash
                  *  row write.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in cache are invalidated on next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
                      /* Once this is executed it's guaranteed the cache has been flushed */
                      (void) CY_CACHE_CONTROL_REG;
              
                      /* Flush the pipeline */
                      CY_SYS_ISB;
              
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 40  

                      /* Restore global interrupt enable state */
                      CyExitCriticalSection(interruptState);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ********************************************************************************
                  * Summary:
                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEM_MANAGE_IRQN         - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  *  address: Pointer to an interrupt service routine.
                  *
                  * Return:
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEMORY_MANAGEMENT_IRQN  - Memory Management Interrupt
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 41  

                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  * Return:
                  *   Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *  address: Pointer to an interrupt service routine
                  *
                  * Return:
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 42  

                  * Return:
                  *  The address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
              
                      return (priority);
                  }
              
              
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 43  

                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ********************************************************************************
                  *
                  * Summary:
                  *   Gets the enable state of the specified interrupt number.
                  *
                  * Parameters:
                  *   number: Valid range [0-31].  Interrupt number.
                  *
                  * Return:
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Get pointer to Interrupt enable register. */
                      stateReg = CY_INT_ENABLE_PTR;
              
                      /* Get state of interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2624          
2625          
2626              /*******************************************************************************
2627              * Function Name: CyIntSetVector
2628              ********************************************************************************
2629              *
2630              * Summary:
2631              *  Sets the interrupt vector of the specified interrupt number.
2632              *
2633              * Parameters:
2634              *  number:  Valid range [0-31].  Interrupt number
2635              *  address: Pointer to an interrupt service routine
2636              *
2637              * Return:
2638              *  Previous interrupt vector value.
2639              *
2640              *******************************************************************************/
2641              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2642              {
2643   1              cyisraddress oldIsr;
2644   1      
2645   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2646   1      
2647   1              /* Save old Interrupt service routine. */
2648   1              oldIsr = (cyisraddress) \
2649   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2650   1      
2651   1              /* Set new Interrupt service routine. */
2652   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2653   1      
2654   1              return (oldIsr);
2655   1          }
2656          
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 44  

2657          
2658              /*******************************************************************************
2659              * Function Name: CyIntGetVector
2660              ********************************************************************************
2661              *
2662              * Summary:
2663              *  Gets the interrupt vector of the specified interrupt number.
2664              *
2665              * Parameters:
2666              *  number: Valid range [0-31].  Interrupt number
2667              *
2668              * Return:
2669              *  Address of the ISR in the interrupt vector table.
2670              *
2671              *******************************************************************************/
2672              cyisraddress CyIntGetVector(uint8 number) 
2673              {
2674   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2675   1      
2676   1              return ((cyisraddress) \
2677   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
2678   1          }
2679          
2680          
2681              /*******************************************************************************
2682              * Function Name: CyIntSetPriority
2683              ********************************************************************************
2684              *
2685              * Summary:
2686              *  Sets the Priority of the Interrupt.
2687              *
2688              * Parameters:
2689              *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2690              *  number:   The number of the interrupt, 0 - 31.
2691              *
2692              * Return:
2693              *  None
2694              *
2695              *******************************************************************************/
2696              void CyIntSetPriority(uint8 number, uint8 priority) 
2697              {
2698   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2699   1      
2700   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2701   1      
2702   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2703   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
2704   1          }
2705          
2706          
2707              /*******************************************************************************
2708              * Function Name: CyIntGetPriority
2709              ********************************************************************************
2710              *
2711              * Summary:
2712              *  Gets the Priority of the Interrupt.
2713              *
2714              * Parameters:
2715              *  number: The number of the interrupt, 0 - 31.
2716              *
2717              * Return:
2718              *  Priority of the interrupt. 0 - 7, 0 being the highest.
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 45  

2719              *
2720              *******************************************************************************/
2721              uint8 CyIntGetPriority(uint8 number) 
2722              {
2723   1              uint8 priority;
2724   1      
2725   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2726   1      
2727   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
2728   1      
2729   1              return (priority);
2730   1          }
2731          
2732          
2733              /*******************************************************************************
2734              * Function Name: CyIntGetState
2735              ********************************************************************************
2736              *
2737              * Summary:
2738              *   Gets the enable state of the specified interrupt number.
2739              *
2740              * Parameters:
2741              *   number: Valid range [0-31].  Interrupt number.
2742              *
2743              * Return:
2744              *   Enable status: 1 if enabled, 0 if disabled
2745              *
2746              *******************************************************************************/
2747              uint8 CyIntGetState(uint8 number) 
2748              {
2749   1              reg8 * stateReg;
2750   1      
2751   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2752   1      
2753   1              /* Get pointer to Interrupt enable register. */
2754   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2755   1      
2756   1              /* Get state of interrupt. */
2757   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2758   1          }
2759          
2760          
2761          #endif  /* (CY_PSOC5) */
2762          
2763          
2764          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  /*******************************************************************************
                  * Function Name: CySetScPumps
                  ********************************************************************************
                  *
                  * Summary:
                  *  If 1 is passed as a parameter:
                  *   - if any of the SC blocks are used - enable pumps for the SC blocks and
                  *     start boost clock.
                  *   - For each enabled SC block set a boost clock index and enable the boost
                  *     clock.
                  *
                  *  If non-1 value is passed as a parameter:
                  *   - If all SC blocks are not used - disable pumps for the SC blocks and
                  *     stop the boost clock.
                  *   - For each enabled SC block clear the boost clock index and disable the
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 46  

                  *     boost clock.
                  *
                  *  The global variable CyScPumpEnabled is updated to be equal to passed the
                  *  parameter.
                  *
                  * Parameters:
                  *   uint8 enable: Enable/disable SC pumps and the boost clock for the enabled
                  *                 SC block:
                  *                 1 - Enable
                  *                 0 - Disable
                  *
                  * Return:
                  *   None
                  *
                  *******************************************************************************/
                  void CySetScPumps(uint8 enable) 
                  {
                      if(1u == enable)
                      {
                          /* The SC pumps should be enabled */
                          CyScPumpEnabled = 1u;
                          /* Enable pumps if any of SC blocks are used */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                          {
                              CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
                              CyScBoostClk_Start();
                          }
                          /* Set positive pump for each enabled SC block: set clock index and enable it */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                          {
                              CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                          {
                              CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                          {
                              CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                          {
                              CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                      }
                      else
                      {
                          /* The SC pumps should be disabled */
                          CyScPumpEnabled = 0u;
                          /* Disable pumps for all SC blocks and stop boost clock */
                          CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                          CyScBoostClk_Stop();
                          /* Disable boost clock and clear clock index for each SC block */
                          CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 47  

                          CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                      }
                  }
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2850          
2851          
2852          #if(CY_PSOC5)
                  /*******************************************************************************
                  * Function Name: CySysTickStart
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the SysTick timer to generate interrupt every 1 ms by call to the
                  *  CySysTickInit() function and starts it by calling CySysTickEnable() function.
                  *  Refer to the corresponding function description for the details.
              
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStart(void)
                  {
                      if (0u == CySysTickInitVar)
                      {
                          CySysTickInit();
                          CySysTickInitVar = 1u;
                      }
              
                      CySysTickEnable();
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickInit
                  ********************************************************************************
                  *
                  * Summary:
                  *  Initializes the callback addresses with pointers to NULL, associates the
                  *  SysTick system vector with the function that is responsible for calling
                  *  registered callback functions, configures SysTick timer to generate interrupt
                  * every 1 ms.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 48  

                  *  Clears SysTick count flag if it was set.
                  *
                  *  The 1 ms interrupt interval is configured based on the frequency determined
                  *  by PSoC Creator at build time. If System clock frequency is changed in
                  *  runtime, the CyDelayFreq() with the appropriate parameter should be called.
                  *
                  *******************************************************************************/
                  void CySysTickInit(void)
                  {
                      uint32 i;
              
                      for (i = 0u; i<CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                      {
                          CySysTickCallbacks[i] = (void *) 0;
                      }
              
                      (void) CyIntSetSysVector(CY_INT_SYSTICK_IRQN, &CySysTickServiceCallbacks);
                      CySysTickSetClockSource(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK);
                      CySysTickSetReload(cydelay_freq_hz/1000u);
                      CySysTickClear();
                      CyIntEnable(CY_INT_SYSTICK_IRQN);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnable
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick timer and its interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnable(void)
                  {
                      CySysTickEnableInterrupt();
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickStop
                  ********************************************************************************
                  *
                  * Summary:
                  *  Stops the system timer (SysTick).
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 49  

                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStop(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE_INT;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickDisableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Disables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickDisableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE_INT));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero. This
                  *  function do not change or reset current sysTick counter value, so it should
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 50  

                  *  be cleared using CySysTickClear() API.
                  *
                  * Parameters:
                  *  value: Valid range [0x0-0x00FFFFFF]. Counter reset value.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickSetReload(uint32 value)
                  {
                      CY_SYS_SYST_RVR_REG = (value & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Counter reset value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetReload(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetValue
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets current SysTick counter value.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Current SysTick counter value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetValue(void)
                  {
                      return(CY_SYS_SYST_CVR_REG & CY_SYS_SYST_CVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetClockSource
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the clock source for the SysTick counter.
                  *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 51  

                  * Parameters:
                  *  clockSource: Clock source for SysTick counter
                  *         Define                     Clock Source
                  *   CY_SYS_SYST_CSR_CLK_SRC_SYSCLK     SysTick is clocked by CPU clock.
                  *   CY_SYS_SYST_CSR_CLK_SRC_LFCLK      SysTick is clocked by the low frequency
                  *                                      clock (ILO 100 KHz for PSoC 5LP, and
                  *                                      LFCLK for PSoC 4).
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set. If clock source is not ready this
                  *  function call will have no effect. After changing clock source to the low
                  *  frequency clock the counter and reload register values will remain unchanged
                  *  so time to the interrupt will be significantly bigger and vice versa.
                  *
                  *******************************************************************************/
                  void CySysTickSetClockSource(uint32 clockSource)
                  {
                      if (clockSource == CY_SYS_SYST_CSR_CLK_SRC_SYSCLK)
                      {
                          CY_SYS_SYST_CSR_REG |= (uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURCE_S
             -HIFT);
                      }
                      else
                      {
                          CY_SYS_SYST_CSR_REG &= ((uint32) ~((uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_
             -CLK_SOURCE_SHIFT)));
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCountFlag
                  ********************************************************************************
                  *
                  * Summary:
                  *  The count flag is set once SysTick counter reaches zero.
                  *   The flag cleared on read.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Returns non-zero value if flag is set, otherwise zero is returned.
                  *
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set.
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetCountFlag(void)
                  {
                      return ((CY_SYS_SYST_CSR_REG >> CY_SYS_SYST_CSR_COUNTFLAG_SHIFT) & 0x01u);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickClear
                  ********************************************************************************
                  *
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 52  

                  * Summary:
                  *  Clears the SysTick counter for well-defined startup.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickClear(void)
                  {
                      CY_SYS_SYST_CVR_REG = 0u;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetCallback
                  ********************************************************************************
                  *
                  * Summary:
                  *  This function allows up to five user-defined interrupt service routine
                  *  functions to be associated with the SysTick interrupt. These are specified
                  *  through the use of pointers to the function.
                  *
                  *  To set a custom callback function without the overhead of the system provided
                  *  one, use CyIntSetSysVector(CY_INT_SYSTICK_IRQN, cyisraddress <address>),
                  *  where <address> is address of the custom defined interrupt service routine.
                  *  Note: a custom callback function overrides the system defined callback
                  *  functions.
                  *
                  * Parameters:
                  *  number: The number of the callback function addresses to be set. The valid
                  *          range is from 0 to 4.
                  *
                  *  void(*CallbackFunction(void): A pointer to the function that will be
                  *                                associated with the SysTick ISR for the
                  *                                specified number.
                  *
                  * Return:
                  *  Returns the address of the previous callback function.
                  *  The NULL is returned if the specified address in not set.
                  *
                  * Side Effects:
                  *  The registered callback functions will be executed in the interrupt.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickSetCallback(uint32 number, cySysTickCallback function)
                  {
                      cySysTickCallback retVal;
              
                      retVal = CySysTickCallbacks[number];
                      CySysTickCallbacks[number] = function;
                      return (retVal);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCallback
                  ********************************************************************************
                  *
                  * Summary:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 53  

                  *  The function get the specified callback pointer.
                  *
                  * Parameters:
                  *  number: The number of callback function address to get. The valid
                  *          range is from 0 to 4.
                  *
                  * Return:
                  *  Returns the address of the specified callback function.
                  *  The NULL is returned if the specified address in not initialized.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickGetCallback(uint32 number)
                  {
                      return ((cySysTickCallback) CySysTickCallbacks[number]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickServiceCallbacks
                  ********************************************************************************
                  *
                  * Summary:
                  *  System Tick timer interrupt routine
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  static void CySysTickServiceCallbacks(void)
                  {
                      uint32 i;
              
                      /* Verify that tick timer flag was set */
                      if (1u == CySysTickGetCountFlag())
                      {
                          for (i=0u; i < CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                          {
                              if (CySysTickCallbacks[i] != (void *) 0)
                              {
                                  (void)(CySysTickCallbacks[i])();
                              }
                          }
                      }
                  }
              #endif /* (CY_PSOC5) */
3257          
3258          
3259          /*******************************************************************************
3260          * Function Name: CyGetUniqueId
3261          ********************************************************************************
3262          *
3263          * Summary:
3264          *  Returns the 64-bit unique ID of the device. The uniqueness of the number is
3265          *  guaranteed for 10 years due to the die lot number having a cycle life of 10
3266          *  years and even after 10 years, the probability of getting two identical
3267          *  numbers is very small.
3268          *
3269          * Parameters:
3270          *  uniqueId: The pointer to a two element 32-bit unsigned integer array. Returns
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 54  

3271          *  the 64-bit unique ID of the device by loading them into the integer array
3272          *  pointed to by uniqueId.
3273          *
3274          * Return:
3275          *  None
3276          *
3277          *******************************************************************************/
3278          void CyGetUniqueId(uint32* uniqueId)
3279          {
3280   1      #if(CY_PSOC4)
                  uniqueId[0u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT0  );
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT1  ) <<  8u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT2  ) << 16u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_WAFER ) << 24u);
              
                  uniqueId[1u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_X     );
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_Y     ) <<  8u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_SORT  ) << 16u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_MINOR ) << 24u);
              #else
3291   1          uniqueId[0u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_LSB   ));
3292   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_MSB   )) <<  8
             -u);
3293   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_MLOGIC_REV_ID                )) << 16
             -u);
3294   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WAFER_NUM )) << 24
             -u);
3295   1      
3296   1          uniqueId[1u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_X_LOC     ));
3297   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_Y_LOC     )) <<  8
             -u);
3298   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WRK_WK    )) << 16
             -u);
3299   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_FAB_YR    )) << 24
             -u);
3300   1      #endif  /* (CY_PSOC4) */
3301   1      }
3302          
3303          /* [] END OF FILE */
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 55  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _CyPLL_OUT_Start (BEGIN)
                                           ; SOURCE LINE # 95
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 96
                                           ; SOURCE LINE # 97
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#status
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 105
0005 904220            MOV     DPTR,#04220H
0008 E0                MOVX    A,@DPTR
0009 4401              ORL     A,#01H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 107
000C EF                MOV     A,R7
000D 6059              JZ      ?C0001
                                           ; SOURCE LINE # 108
                                           ; SOURCE LINE # 110
000F 904300            MOV     DPTR,#04300H
0012 E0                MOVX    A,@DPTR
0013 5404              ANL     A,#04H
0015 900000      R     MOV     DPTR,#iloEnableState
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 111
0019 904380            MOV     DPTR,#04380H
001C E0                MOVX    A,@DPTR
001D 900000      R     MOV     DPTR,#pmTwCfg0State
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
0021 904382            MOV     DPTR,#04382H
0024 E0                MOVX    A,@DPTR
0025 900000      R     MOV     DPTR,#pmTwCfg2State
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0029 7F18              MOV     R7,#018H
002B 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 116
002E 900000      R     MOV     DPTR,#status
0031 7410              MOV     A,#010H
0033 F0                MOVX    @DPTR,A
0034         ?C0002:
                                           ; SOURCE LINE # 118
0034 7F01              MOV     R7,#01H
0036 120000      E     LCALL   _CyPmReadStatus
0039 EF                MOV     A,R7
003A 20E012            JB      ACC.0,?C0003
                                           ; SOURCE LINE # 119
                                           ; SOURCE LINE # 121
003D 904225            MOV     DPTR,#04225H
0040 E0                MOVX    A,@DPTR
0041 5401              ANL     A,#01H
0043 60EF              JZ      ?C0002
                                           ; SOURCE LINE # 122
                                           ; SOURCE LINE # 123
0045 E0                MOVX    A,@DPTR
0046 5401              ANL     A,#01H
0048 60EA              JZ      ?C0002
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 56  

004A E4                CLR     A
004B 900000      R     MOV     DPTR,#status
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
                                           ; SOURCE LINE # 127
                                           ; SOURCE LINE # 128
                                           ; SOURCE LINE # 129
004F         ?C0003:
                                           ; SOURCE LINE # 132
004F 900000      R     MOV     DPTR,#iloEnableState
0052 E0                MOVX    A,@DPTR
0053 7003              JNZ     ?C0006
                                           ; SOURCE LINE # 133
                                           ; SOURCE LINE # 134
0055 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 135
0058         ?C0006:
                                           ; SOURCE LINE # 137
0058 900000      R     MOV     DPTR,#pmTwCfg0State
005B E0                MOVX    A,@DPTR
005C 904380            MOV     DPTR,#04380H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 138
0060 900000      R     MOV     DPTR,#pmTwCfg2State
0063 E0                MOVX    A,@DPTR
0064 904382            MOV     DPTR,#04382H
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
0068         ?C0001:
                                           ; SOURCE LINE # 141
0068 900000      R     MOV     DPTR,#status
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
                                           ; SOURCE LINE # 142
006D         ?C0007:
006D 22                RET     
             ; FUNCTION _CyPLL_OUT_Start (END)

             ; FUNCTION CyPLL_OUT_Stop (BEGIN)
                                           ; SOURCE LINE # 159
                                           ; SOURCE LINE # 160
                                           ; SOURCE LINE # 161
0000 904220            MOV     DPTR,#04220H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
0007 22                RET     
             ; FUNCTION CyPLL_OUT_Stop (END)

             ; FUNCTION _CyPLL_OUT_SetPQ (BEGIN)
                                           ; SOURCE LINE # 197
0000 900000      R     MOV     DPTR,#pDiv
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EB                MOV     A,R3
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 57  

                                           ; SOURCE LINE # 200
000B 904220            MOV     DPTR,#04220H
000E E0                MOVX    A,@DPTR
000F 5401              ANL     A,#01H
0011 7003              JNZ     ?C0010
0013 D3                SETB    C
0014 8001              SJMP    ?C0011
0016         ?C0010:
0016 C3                CLR     C
0017         ?C0011:
0017 4005              JC      ?C0009
0019 7F00              MOV     R7,#00H
001B 120000      R     LCALL   _?CyHalt
001E         ?C0009:
                                           ; SOURCE LINE # 202
001E 900000      R     MOV     DPTR,#pDiv
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 C3                CLR     C
0024 9408              SUBB    A,#08H
0026 403C              JC      ?C0012
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FE                MOV     R6,A
002B D3                SETB    C
002C 9410              SUBB    A,#010H
002E 5034              JNC     ?C0012
0030 EE                MOV     A,R6
0031 C3                CLR     C
0032 9401              SUBB    A,#01H
0034 402E              JC      ?C0012
0036 A3                INC     DPTR
0037 E0                MOVX    A,@DPTR
0038 FE                MOV     R6,A
0039 9401              SUBB    A,#01H
003B 4027              JC      ?C0012
003D EE                MOV     A,R6
003E D3                SETB    C
003F 9407              SUBB    A,#07H
0041 5021              JNC     ?C0012
                                           ; SOURCE LINE # 205
                                           ; SOURCE LINE # 207
0043 904222            MOV     DPTR,#04222H
0046 EF                MOV     A,R7
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 208
0048 900000      R     MOV     DPTR,#qDiv
004B E0                MOVX    A,@DPTR
004C 14                DEC     A
004D 904223            MOV     DPTR,#04223H
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 210
0051 900000      R     MOV     DPTR,#current
0054 E0                MOVX    A,@DPTR
0055 14                DEC     A
0056 FF                MOV     R7,A
0057 C4                SWAP    A
0058 54F0              ANL     A,#0F0H
005A FF                MOV     R7,A
005B 904221            MOV     DPTR,#04221H
005E E0                MOVX    A,@DPTR
005F 548F              ANL     A,#08FH
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 58  

0061 4F                ORL     A,R7
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 211
0063 22                RET     
0064         ?C0012:
                                           ; SOURCE LINE # 213
                                           ; SOURCE LINE # 220
0064 7F00              MOV     R7,#00H
0066 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 221
                                           ; SOURCE LINE # 223
0069         ?C0015:
0069 22                RET     
             ; FUNCTION _CyPLL_OUT_SetPQ (END)

             ; FUNCTION _CyPLL_OUT_SetSource (BEGIN)
                                           ; SOURCE LINE # 252
0000 900000      R     MOV     DPTR,#source
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 253
                                           ; SOURCE LINE # 255
0005 904220            MOV     DPTR,#04220H
0008 E0                MOVX    A,@DPTR
0009 5401              ANL     A,#01H
000B 7003              JNZ     ?C0017
000D D3                SETB    C
000E 8001              SJMP    ?C0018
0010         ?C0017:
0010 C3                CLR     C
0011         ?C0018:
0011 4005              JC      ?C0016
0013 7F00              MOV     R7,#00H
0015 120000      R     LCALL   _?CyHalt
0018         ?C0016:
                                           ; SOURCE LINE # 257
0018 900000      R     MOV     DPTR,#source
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 24FD              ADD     A,#0FDH
001F 5002              JNC     ?C0022
0021 8009              SJMP    ?C0023
                                           ; SOURCE LINE # 258
                                           ; SOURCE LINE # 259
                                           ; SOURCE LINE # 260
                                           ; SOURCE LINE # 261
0023         ?C0022:
                                           ; SOURCE LINE # 262
0023 904000            MOV     DPTR,#04000H
0026 E0                MOVX    A,@DPTR
0027 54FC              ANL     A,#0FCH
0029 4F                ORL     A,R7
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 263
002B 22                RET     
                                           ; SOURCE LINE # 265
002C         ?C0023:
                                           ; SOURCE LINE # 266
002C 7F00              MOV     R7,#00H
002E 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 268
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 59  

                                           ; SOURCE LINE # 269
0031         ?C0025:
0031 22                RET     
             ; FUNCTION _CyPLL_OUT_SetSource (END)

             ; FUNCTION _CyIMO_Start (BEGIN)
                                           ; SOURCE LINE # 302
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 303
                                           ; SOURCE LINE # 309
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 310
0007 9043B0            MOV     DPTR,#043B0H
000A E0                MOVX    A,@DPTR
000B 4410              ORL     A,#010H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 312
000E EF                MOV     A,R7
000F 6041              JZ      ?C0030
                                           ; SOURCE LINE # 313
                                           ; SOURCE LINE # 315
0011 904300            MOV     DPTR,#04300H
0014 E0                MOVX    A,@DPTR
0015 5404              ANL     A,#04H
0017 900000      R     MOV     DPTR,#ilo100KhzEnable
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 316
001B 904380            MOV     DPTR,#04380H
001E E0                MOVX    A,@DPTR
001F 900000      R     MOV     DPTR,#pmFtwCfg0Reg
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 317
0023 904382            MOV     DPTR,#04382H
0026 E0                MOVX    A,@DPTR
0027 900000      R     MOV     DPTR,#pmFtwCfg2Reg
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 319
002B E4                CLR     A
002C FF                MOV     R7,A
002D 120000      E     LCALL   _CyPmFtwSetInterval
0030         ?C0027:
                                           ; SOURCE LINE # 321
0030 7F01              MOV     R7,#01H
0032 120000      E     LCALL   _CyPmReadStatus
0035 EF                MOV     A,R7
0036 30E0F7            JNB     ACC.0,?C0027
                                           ; SOURCE LINE # 322
                                           ; SOURCE LINE # 324
0039         ?C0028:
                                           ; SOURCE LINE # 326
0039 900000      R     MOV     DPTR,#ilo100KhzEnable
003C E0                MOVX    A,@DPTR
003D 7003              JNZ     ?C0029
                                           ; SOURCE LINE # 327
                                           ; SOURCE LINE # 328
003F 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 329
0042         ?C0029:
                                           ; SOURCE LINE # 331
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 60  

0042 900000      R     MOV     DPTR,#pmFtwCfg0Reg
0045 E0                MOVX    A,@DPTR
0046 904380            MOV     DPTR,#04380H
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 332
004A 900000      R     MOV     DPTR,#pmFtwCfg2Reg
004D E0                MOVX    A,@DPTR
004E 904382            MOV     DPTR,#04382H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 333
                                           ; SOURCE LINE # 334
0052         ?C0030:
0052 22                RET     
             ; FUNCTION _CyIMO_Start (END)

             ; FUNCTION CyIMO_Stop (BEGIN)
                                           ; SOURCE LINE # 351
                                           ; SOURCE LINE # 352
                                           ; SOURCE LINE # 353
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 354
0007 9043B0            MOV     DPTR,#043B0H
000A E0                MOVX    A,@DPTR
000B 54EF              ANL     A,#0EFH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 355
000E 22                RET     
             ; FUNCTION CyIMO_Stop (END)

             ; FUNCTION CyUSB_PowerOnCheck (BEGIN)
                                           ; SOURCE LINE # 372
                                           ; SOURCE LINE # 373
                                           ; SOURCE LINE # 374
;---- Variable 'poweredOn' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 380
0002 904393            MOV     DPTR,#04393H
0005 E0                MOVX    A,@DPTR
0006 5407              ANL     A,#07H
0008 7008              JNZ     ?C0034
000A 9043A5            MOV     DPTR,#043A5H
000D E0                MOVX    A,@DPTR
000E 5401              ANL     A,#01H
0010 7012              JNZ     ?C0033
0012         ?C0034:
0012 904393            MOV     DPTR,#04393H
0015 E0                MOVX    A,@DPTR
0016 5407              ANL     A,#07H
0018 6401              XRL     A,#01H
001A 700A              JNZ     ?C0032
001C 9043B5            MOV     DPTR,#043B5H
001F E0                MOVX    A,@DPTR
0020 5401              ANL     A,#01H
0022 6002              JZ      ?C0032
0024         ?C0033:
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
0024 7F01              MOV     R7,#01H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 61  

                                           ; SOURCE LINE # 383
0026         ?C0032:
                                           ; SOURCE LINE # 385
                                           ; SOURCE LINE # 386
0026         ?C0035:
0026 22                RET     
             ; FUNCTION CyUSB_PowerOnCheck (END)

             ; FUNCTION _CyIMO_SetTrimValue (BEGIN)
                                           ; SOURCE LINE # 403
;---- Variable 'freq' assigned to Register 'R6' ----
0000 AE07              MOV     R6,AR7
                                           ; SOURCE LINE # 404
                                           ; SOURCE LINE # 405
0002 120000      R     LCALL   CyUSB_PowerOnCheck
0005 900000      R     MOV     DPTR,#usbPowerOn
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 408
000A B40107            CJNE    A,#01H,?C0036
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 411
000D 906009            MOV     DPTR,#06009H
0010 E0                MOVX    A,@DPTR
0011 54FD              ANL     A,#0FDH
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 412
0014         ?C0036:
                                           ; SOURCE LINE # 413
0014 EE                MOV     A,R6
0015 120000      E     LCALL   ?C?CCASE
0018 0000        R     DW      ?C0038
001A 00                DB      00H
001B 0000        R     DW      ?C0039
001D 01                DB      01H
001E 0000        R     DW      ?C0040
0020 02                DB      02H
0021 0000        R     DW      ?C0041
0023 03                DB      03H
0024 0000        R     DW      ?C0042
0026 04                DB      04H
0027 0000        R     DW      ?C0043
0029 05                DB      05H
002A 0000        R     DW      ?C0044
002C 08                DB      08H
002D 0000              DW      00H
002F 0000        R     DW      ?C0046
                                           ; SOURCE LINE # 414
                                           ; SOURCE LINE # 415
0031         ?C0038:
                                           ; SOURCE LINE # 416
0031 7B0C              MOV     R3,#0CH
0033 7A01              MOV     R2,#01H
0035 7908              MOV     R1,#08H
0037 120000      E     LCALL   _cyread8
003A 9046A1            MOV     DPTR,#046A1H
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 417
003F 22                RET     
                                           ; SOURCE LINE # 419
0040         ?C0039:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 62  

                                           ; SOURCE LINE # 420
0040 7B0C              MOV     R3,#0CH
0042 7A01              MOV     R2,#01H
0044 7909              MOV     R1,#09H
0046 120000      E     LCALL   _cyread8
0049 9046A1            MOV     DPTR,#046A1H
004C EF                MOV     A,R7
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 421
004E 22                RET     
                                           ; SOURCE LINE # 423
004F         ?C0040:
                                           ; SOURCE LINE # 424
004F 7B0C              MOV     R3,#0CH
0051 7A01              MOV     R2,#01H
0053 790A              MOV     R1,#0AH
0055 120000      E     LCALL   _cyread8
0058 9046A1            MOV     DPTR,#046A1H
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 425
005D 22                RET     
                                           ; SOURCE LINE # 427
005E         ?C0041:
                                           ; SOURCE LINE # 428
005E 7B0C              MOV     R3,#0CH
0060 7A01              MOV     R2,#01H
0062 790B              MOV     R1,#0BH
0064 120000      E     LCALL   _cyread8
0067 9046A1            MOV     DPTR,#046A1H
006A EF                MOV     A,R7
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 429
006C 22                RET     
                                           ; SOURCE LINE # 431
006D         ?C0042:
                                           ; SOURCE LINE # 432
006D 7B0C              MOV     R3,#0CH
006F 7A01              MOV     R2,#01H
0071 7989              MOV     R1,#089H
0073 120000      E     LCALL   _cyread8
0076 9046A1            MOV     DPTR,#046A1H
0079 EF                MOV     A,R7
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 433
007B 22                RET     
                                           ; SOURCE LINE # 435
007C         ?C0043:
                                           ; SOURCE LINE # 436
007C 7B0C              MOV     R3,#0CH
007E 7A01              MOV     R2,#01H
0080 790C              MOV     R1,#0CH
0082 120000      E     LCALL   _cyread8
0085 9046A1            MOV     DPTR,#046A1H
0088 EF                MOV     A,R7
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 437
008A 22                RET     
                                           ; SOURCE LINE # 445
008B         ?C0044:
                                           ; SOURCE LINE # 446
008B 7B0C              MOV     R3,#0CH
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 63  

008D 7A01              MOV     R2,#01H
008F 790F              MOV     R1,#0FH
0091 120000      E     LCALL   _cyread8
0094 9046A1            MOV     DPTR,#046A1H
0097 EF                MOV     A,R7
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 449
0099 900000      R     MOV     DPTR,#usbPowerOn
009C E0                MOVX    A,@DPTR
009D B4010D            CJNE    A,#01H,?C0048
                                           ; SOURCE LINE # 450
                                           ; SOURCE LINE # 452
00A0 906009            MOV     DPTR,#06009H
00A3 E0                MOVX    A,@DPTR
00A4 4402              ORL     A,#02H
00A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 453
                                           ; SOURCE LINE # 454
00A7 22                RET     
                                           ; SOURCE LINE # 456
00A8         ?C0046:
                                           ; SOURCE LINE # 457
00A8 7F00              MOV     R7,#00H
00AA 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 458
                                           ; SOURCE LINE # 459
                                           ; SOURCE LINE # 461
00AD         ?C0048:
00AD 22                RET     
             ; FUNCTION _CyIMO_SetTrimValue (END)

             ; FUNCTION _CyIMO_SetFreq (BEGIN)
                                           ; SOURCE LINE # 498
0000 900000      R     MOV     DPTR,#freq
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 510
0005 904200            MOV     DPTR,#04200H
0008 E0                MOVX    A,@DPTR
0009 5407              ANL     A,#07H
000B 900000      R     MOV     DPTR,#currentFreq
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 513
000F 900000      R     MOV     DPTR,#freq
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 B40806            CJNE    A,#08H,?C0049
0017 7E03              MOV     R6,#03H
0019 7F03              MOV     R7,#03H
001B 8000              SJMP    ?C0050
001D         ?C0049:
001D         ?C0050:
001D 900000      R     MOV     DPTR,#nextFreq
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 515
0022 900000      R     MOV     DPTR,#currentFreq
0025 E0                MOVX    A,@DPTR
0026 14                DEC     A
0027 6018              JZ      ?C0053
0029 14                DEC     A
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 64  

002A 601D              JZ      ?C0054
002C 14                DEC     A
002D 6022              JZ      ?C0055
002F 14                DEC     A
0030 6026              JZ      ?C0056
0032 14                DEC     A
0033 602B              JZ      ?C0057
0035 2405              ADD     A,#05H
0037 702F              JNZ     ?C0058
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 517
0039         ?C0052:
                                           ; SOURCE LINE # 518
0039 900000      R     MOV     DPTR,#currentFreq
003C 7402              MOV     A,#02H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 519
003F 802C              SJMP    ?C0051
                                           ; SOURCE LINE # 521
0041         ?C0053:
                                           ; SOURCE LINE # 522
0041 900000      R     MOV     DPTR,#currentFreq
0044 7401              MOV     A,#01H
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
0047 8024              SJMP    ?C0051
                                           ; SOURCE LINE # 525
0049         ?C0054:
                                           ; SOURCE LINE # 526
0049 900000      R     MOV     DPTR,#currentFreq
004C 7403              MOV     A,#03H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 527
004F 801C              SJMP    ?C0051
                                           ; SOURCE LINE # 529
0051         ?C0055:
                                           ; SOURCE LINE # 530
0051 E4                CLR     A
0052 900000      R     MOV     DPTR,#currentFreq
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 531
0056 8015              SJMP    ?C0051
                                           ; SOURCE LINE # 533
0058         ?C0056:
                                           ; SOURCE LINE # 534
0058 900000      R     MOV     DPTR,#currentFreq
005B 7404              MOV     A,#04H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 535
005E 800D              SJMP    ?C0051
                                           ; SOURCE LINE # 537
0060         ?C0057:
                                           ; SOURCE LINE # 538
0060 900000      R     MOV     DPTR,#currentFreq
0063 7405              MOV     A,#05H
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 539
0066 8005              SJMP    ?C0051
                                           ; SOURCE LINE # 547
0068         ?C0058:
                                           ; SOURCE LINE # 548
0068 7F00              MOV     R7,#00H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 65  

006A 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 549
                                           ; SOURCE LINE # 550
006D         ?C0051:
                                           ; SOURCE LINE # 552
006D 900000      R     MOV     DPTR,#currentFreq
0070 E0                MOVX    A,@DPTR
0071 FF                MOV     R7,A
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 C3                CLR     C
0075 9F                SUBB    A,R7
0076 4008              JC      ?C0060
                                           ; SOURCE LINE # 553
                                           ; SOURCE LINE # 555
0078 900000      R     MOV     DPTR,#freq
007B E0                MOVX    A,@DPTR
007C FF                MOV     R7,A
007D 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 556
0080         ?C0060:
                                           ; SOURCE LINE # 559
0080 900000      R     MOV     DPTR,#freq
0083 E0                MOVX    A,@DPTR
0084 120000      E     LCALL   ?C?CCASE
0087 0000        R     DW      ?C0062
0089 00                DB      00H
008A 0000        R     DW      ?C0063
008C 01                DB      01H
008D 0000        R     DW      ?C0064
008F 02                DB      02H
0090 0000        R     DW      ?C0065
0092 03                DB      03H
0093 0000        R     DW      ?C0066
0095 04                DB      04H
0096 0000        R     DW      ?C0067
0098 05                DB      05H
0099 0000        R     DW      ?C0068
009B 08                DB      08H
009C 0000              DW      00H
009E 0000        R     DW      ?C0069
                                           ; SOURCE LINE # 560
                                           ; SOURCE LINE # 561
00A0         ?C0062:
                                           ; SOURCE LINE # 563
00A0 904200            MOV     DPTR,#04200H
00A3 E0                MOVX    A,@DPTR
00A4 54F8              ANL     A,#0F8H
00A6 4403              ORL     A,#03H
00A8 54BF              ANL     A,#0BFH
00AA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 564
00AB 804D              SJMP    ?C0061
                                           ; SOURCE LINE # 566
00AD         ?C0063:
                                           ; SOURCE LINE # 568
00AD 904200            MOV     DPTR,#04200H
00B0 E0                MOVX    A,@DPTR
00B1 54F8              ANL     A,#0F8H
00B3 4401              ORL     A,#01H
00B5 54BF              ANL     A,#0BFH
00B7 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 66  

                                           ; SOURCE LINE # 569
00B8 8040              SJMP    ?C0061
                                           ; SOURCE LINE # 571
00BA         ?C0064:
                                           ; SOURCE LINE # 573
00BA 904200            MOV     DPTR,#04200H
00BD E0                MOVX    A,@DPTR
00BE 54B8              ANL     A,#0B8H
00C0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 574
00C1 8037              SJMP    ?C0061
                                           ; SOURCE LINE # 576
00C3         ?C0065:
                                           ; SOURCE LINE # 578
00C3 904200            MOV     DPTR,#04200H
00C6 E0                MOVX    A,@DPTR
00C7 54F8              ANL     A,#0F8H
00C9 4402              ORL     A,#02H
00CB 54BF              ANL     A,#0BFH
00CD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 579
00CE 802A              SJMP    ?C0061
                                           ; SOURCE LINE # 581
00D0         ?C0066:
                                           ; SOURCE LINE # 583
00D0 904200            MOV     DPTR,#04200H
00D3 E0                MOVX    A,@DPTR
00D4 54F8              ANL     A,#0F8H
00D6 4404              ORL     A,#04H
00D8 54BF              ANL     A,#0BFH
00DA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 584
00DB 801D              SJMP    ?C0061
                                           ; SOURCE LINE # 586
00DD         ?C0067:
                                           ; SOURCE LINE # 588
00DD 904200            MOV     DPTR,#04200H
00E0 E0                MOVX    A,@DPTR
00E1 54F8              ANL     A,#0F8H
00E3 4405              ORL     A,#05H
00E5 54BF              ANL     A,#0BFH
00E7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 589
00E8 8010              SJMP    ?C0061
                                           ; SOURCE LINE # 598
00EA         ?C0068:
                                           ; SOURCE LINE # 599
00EA 904200            MOV     DPTR,#04200H
00ED E0                MOVX    A,@DPTR
00EE 54F8              ANL     A,#0F8H
00F0 4442              ORL     A,#042H
00F2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 601
00F3 8005              SJMP    ?C0061
                                           ; SOURCE LINE # 603
00F5         ?C0069:
                                           ; SOURCE LINE # 604
00F5 7F00              MOV     R7,#00H
00F7 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 605
                                           ; SOURCE LINE # 606
00FA         ?C0061:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 67  

                                           ; SOURCE LINE # 609
00FA 900000      R     MOV     DPTR,#freq
00FD E0                MOVX    A,@DPTR
00FE B40805            CJNE    A,#08H,?C0071
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 611
0101 120000      R     LCALL   CyIMO_EnableDoubler
                                           ; SOURCE LINE # 612
0104 8003              SJMP    ?C0072
0106         ?C0071:
                                           ; SOURCE LINE # 614
                                           ; SOURCE LINE # 615
0106 120000      R     LCALL   CyIMO_DisableDoubler
                                           ; SOURCE LINE # 616
0109         ?C0072:
                                           ; SOURCE LINE # 618
0109 900000      R     MOV     DPTR,#currentFreq
010C E0                MOVX    A,@DPTR
010D FF                MOV     R7,A
010E A3                INC     DPTR
010F E0                MOVX    A,@DPTR
0110 C3                CLR     C
0111 9F                SUBB    A,R7
0112 5008              JNC     ?C0074
                                           ; SOURCE LINE # 619
                                           ; SOURCE LINE # 621
0114 900000      R     MOV     DPTR,#freq
0117 E0                MOVX    A,@DPTR
0118 FF                MOV     R7,A
0119 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 622
                                           ; SOURCE LINE # 623
011C         ?C0074:
011C 22                RET     
             ; FUNCTION _CyIMO_SetFreq (END)

             ; FUNCTION _CyIMO_SetSource (BEGIN)
                                           ; SOURCE LINE # 653
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 654
                                           ; SOURCE LINE # 655
0000 EF                MOV     A,R7
0001 6024              JZ      ?C0078
0003 14                DEC     A
0004 6012              JZ      ?C0077
0006 14                DEC     A
0007 7026              JNZ     ?C0079
                                           ; SOURCE LINE # 656
                                           ; SOURCE LINE # 657
0009         ?C0076:
                                           ; SOURCE LINE # 658
0009 904000            MOV     DPTR,#04000H
000C E0                MOVX    A,@DPTR
000D 54BF              ANL     A,#0BFH
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 659
0010 904200            MOV     DPTR,#04200H
0013 E0                MOVX    A,@DPTR
0014 4420              ORL     A,#020H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 660
0017 22                RET     
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 68  

                                           ; SOURCE LINE # 662
0018         ?C0077:
                                           ; SOURCE LINE # 663
0018 904000            MOV     DPTR,#04000H
001B E0                MOVX    A,@DPTR
001C 4440              ORL     A,#040H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 664
001F 904200            MOV     DPTR,#04200H
0022 E0                MOVX    A,@DPTR
0023 4420              ORL     A,#020H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 665
0026 22                RET     
                                           ; SOURCE LINE # 667
0027         ?C0078:
                                           ; SOURCE LINE # 668
0027 904200            MOV     DPTR,#04200H
002A E0                MOVX    A,@DPTR
002B 54DF              ANL     A,#0DFH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 669
002E 22                RET     
                                           ; SOURCE LINE # 671
002F         ?C0079:
                                           ; SOURCE LINE # 673
002F 7F00              MOV     R7,#00H
0031 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 674
                                           ; SOURCE LINE # 675
                                           ; SOURCE LINE # 676
0034         ?C0081:
0034 22                RET     
             ; FUNCTION _CyIMO_SetSource (END)

             ; FUNCTION CyIMO_EnableDoubler (BEGIN)
                                           ; SOURCE LINE # 694
                                           ; SOURCE LINE # 695
                                           ; SOURCE LINE # 697
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 698
0007 22                RET     
             ; FUNCTION CyIMO_EnableDoubler (END)

             ; FUNCTION CyIMO_DisableDoubler (BEGIN)
                                           ; SOURCE LINE # 715
                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 718
0007 22                RET     
             ; FUNCTION CyIMO_DisableDoubler (END)

             ; FUNCTION _CyMasterClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 750
;---- Variable 'source' assigned to Register 'R7' ----
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 69  

                                           ; SOURCE LINE # 751
                                           ; SOURCE LINE # 753
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904005            MOV     DPTR,#04005H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 754
000C 22                RET     
             ; FUNCTION _CyMasterClk_SetSource (END)

             ; FUNCTION _CyMasterClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 785
;---- Variable 'divider' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 786
                                           ; SOURCE LINE # 787
0000 904004            MOV     DPTR,#04004H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 788
0005 22                RET     
             ; FUNCTION _CyMasterClk_SetDivider (END)

             ; FUNCTION _CyBusClk_Internal_SetDivider (BEGIN)
                                           ; SOURCE LINE # 807
;---- Variable 'divider' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 808
                                           ; SOURCE LINE # 810
0000 904014            MOV     DPTR,#04014H
0003 E0                MOVX    A,@DPTR
0004 54F0              ANL     A,#0F0H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
0007 904010            MOV     DPTR,#04010H
000A E4                CLR     A
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 814
000C 904008            MOV     DPTR,#04008H
000F E0                MOVX    A,@DPTR
0010 4480              ORL     A,#080H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 817
0013 EF                MOV     A,R7
0014 904002            MOV     DPTR,#04002H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 818
0018 EE                MOV     A,R6
0019 A3                INC     DPTR
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 827
001B 904001            MOV     DPTR,#04001H
001E E0                MOVX    A,@DPTR
001F 4401              ORL     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 828
0022 22                RET     
             ; FUNCTION _CyBusClk_Internal_SetDivider (END)

             ; FUNCTION _CyBusClk_SetDivider (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 70  

                                           ; SOURCE LINE # 854
0000 900000      R     MOV     DPTR,#divider
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 855
                                           ; SOURCE LINE # 860
0008 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R1' ----
000B A907              MOV     R1,AR7
                                           ; SOURCE LINE # 863
000D 904007            MOV     DPTR,#04007H
0010 E0                MOVX    A,@DPTR
0011 7F00              MOV     R7,#00H
0013 FE                MOV     R6,A
;---- Variable 'busClkDiv' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 864
0014 904006            MOV     DPTR,#04006H
0017 E0                MOVX    A,@DPTR
0018 FD                MOV     R5,A
0019 EE                MOV     A,R6
001A ED                MOV     A,R5
001B FF                MOV     R7,A
                                           ; SOURCE LINE # 866
001C 900000      R     MOV     DPTR,#divider
001F E0                MOVX    A,@DPTR
0020 7002              JNZ     ?C0198
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024         ?C0198:
0024 6004              JZ      ?C0088
0026 EF                MOV     A,R7
0027 4E                ORL     A,R6
0028 703F              JNZ     ?C0087
002A         ?C0088:
                                           ; SOURCE LINE # 867
                                           ; SOURCE LINE # 869
002A 904004            MOV     DPTR,#04004H
002D E0                MOVX    A,@DPTR
;---- Variable 'masterClkDiv' assigned to Register 'R5' ----
002E FD                MOV     R5,A
                                           ; SOURCE LINE # 871
002F C3                CLR     C
0030 9407              SUBB    A,#07H
0032 5005              JNC     ?C0089
                                           ; SOURCE LINE # 872
                                           ; SOURCE LINE # 874
0034 7F07              MOV     R7,#07H
0036 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 875
0039         ?C0089:
                                           ; SOURCE LINE # 877
0039 900000      R     MOV     DPTR,#divider
003C E0                MOVX    A,@DPTR
003D FE                MOV     R6,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 4E                ORL     A,R6
0042 700C              JNZ     ?C0090
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 71  

                                           ; SOURCE LINE # 878
                                           ; SOURCE LINE # 880
0044 904008            MOV     DPTR,#04008H
0047 E0                MOVX    A,@DPTR
0048 4440              ORL     A,#040H
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 881
004B 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 882
004E 8012              SJMP    ?C0091
0050         ?C0090:
                                           ; SOURCE LINE # 884
                                           ; SOURCE LINE # 885
0050 900000      R     MOV     DPTR,#divider
0053 E0                MOVX    A,@DPTR
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 886
005B 904008            MOV     DPTR,#04008H
005E E0                MOVX    A,@DPTR
005F 54BF              ANL     A,#0BFH
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 887
0062         ?C0091:
                                           ; SOURCE LINE # 890
0062 AF05              MOV     R7,AR5
0064 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 891
0067 800B              SJMP    ?C0092
0069         ?C0087:
                                           ; SOURCE LINE # 893
                                           ; SOURCE LINE # 894
0069 900000      R     MOV     DPTR,#divider
006C E0                MOVX    A,@DPTR
006D FE                MOV     R6,A
006E A3                INC     DPTR
006F E0                MOVX    A,@DPTR
0070 FF                MOV     R7,A
0071 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 895
0074         ?C0092:
                                           ; SOURCE LINE # 897
0074 AF01              MOV     R7,AR1
0076 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 898
0079 22                RET     
             ; FUNCTION _CyBusClk_SetDivider (END)

             ; FUNCTION _CyCpuClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 927
;---- Variable 'divider' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 928
                                           ; SOURCE LINE # 930
0000 EF                MOV     A,R7
0001 C4                SWAP    A
0002 54F0              ANL     A,#0F0H
0004 FF                MOV     R7,A
0005 904005            MOV     DPTR,#04005H
0008 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 72  

0009 540F              ANL     A,#0FH
000B 4F                ORL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 931
000D 22                RET     
             ; FUNCTION _CyCpuClk_SetDivider (END)

             ; FUNCTION _CyUsbClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 954
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 955
                                           ; SOURCE LINE # 956
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904009            MOV     DPTR,#04009H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 958
000C 22                RET     
             ; FUNCTION _CyUsbClk_SetSource (END)

             ; FUNCTION CyILO_Start1K (BEGIN)
                                           ; SOURCE LINE # 979
                                           ; SOURCE LINE # 980
                                           ; SOURCE LINE # 982
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4402              ORL     A,#02H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 983
0007 22                RET     
             ; FUNCTION CyILO_Start1K (END)

             ; FUNCTION CyILO_Stop1K (BEGIN)
                                           ; SOURCE LINE # 1007
                                           ; SOURCE LINE # 1008
                                           ; SOURCE LINE # 1010
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1011
0007 22                RET     
             ; FUNCTION CyILO_Stop1K (END)

             ; FUNCTION CyILO_Start100K (BEGIN)
                                           ; SOURCE LINE # 1028
                                           ; SOURCE LINE # 1029
                                           ; SOURCE LINE # 1030
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1031
0007 22                RET     
             ; FUNCTION CyILO_Start100K (END)

             ; FUNCTION CyILO_Stop100K (BEGIN)
                                           ; SOURCE LINE # 1048
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 73  

                                           ; SOURCE LINE # 1049
                                           ; SOURCE LINE # 1050
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1051
0007 22                RET     
             ; FUNCTION CyILO_Stop100K (END)

             ; FUNCTION CyILO_Enable33K (BEGIN)
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
                                           ; SOURCE LINE # 1074
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4420              ORL     A,#020H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1075
0007 22                RET     
             ; FUNCTION CyILO_Enable33K (END)

             ; FUNCTION CyILO_Disable33K (BEGIN)
                                           ; SOURCE LINE # 1095
                                           ; SOURCE LINE # 1096
                                           ; SOURCE LINE # 1097
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54DF              ANL     A,#0DFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1098
0007 22                RET     
             ; FUNCTION CyILO_Disable33K (END)

             ; FUNCTION _CyILO_SetSource (BEGIN)
                                           ; SOURCE LINE # 1119
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1120
                                           ; SOURCE LINE # 1122
0000 EF                MOV     A,R7
0001 25E0              ADD     A,ACC
0003 25E0              ADD     A,ACC
0005 540C              ANL     A,#0CH
0007 FF                MOV     R7,A
0008 904000            MOV     DPTR,#04000H
000B E0                MOVX    A,@DPTR
000C 54F3              ANL     A,#0F3H
000E 4F                ORL     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1123
0010 22                RET     
             ; FUNCTION _CyILO_SetSource (END)

             ; FUNCTION _CyILO_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1143
;---- Variable 'mode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1144
                                           ; SOURCE LINE # 1148
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 FE                MOV     R6,A
;---- Variable 'state' assigned to Register 'R6' ----
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 74  

                                           ; SOURCE LINE # 1151
0005 EF                MOV     A,R7
0006 6006              JZ      ?C0103
                                           ; SOURCE LINE # 1152
                                           ; SOURCE LINE # 1153
0008 EE                MOV     A,R6
0009 4410              ORL     A,#010H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1154
000C 8007              SJMP    ?C0104
000E         ?C0103:
                                           ; SOURCE LINE # 1156
                                           ; SOURCE LINE # 1157
000E EE                MOV     A,R6
000F 54EF              ANL     A,#0EFH
0011 904300            MOV     DPTR,#04300H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1158
0015         ?C0104:
                                           ; SOURCE LINE # 1161
0015 AF06              MOV     R7,AR6
0017 EE                MOV     A,R6
0018 5410              ANL     A,#010H
001A FF                MOV     R7,A
001B E4                CLR     A
001C C4                SWAP    A
001D F8                MOV     R0,A
001E 54F0              ANL     A,#0F0H
0020 C8                XCH     A,R0
0021 68                XRL     A,R0
0022 EF                MOV     A,R7
0023 C4                SWAP    A
0024 540F              ANL     A,#0FH
0026 48                ORL     A,R0
0027 FF                MOV     R7,A
                                           ; SOURCE LINE # 1162
0028         ?C0105:
0028 22                RET     
             ; FUNCTION _CyILO_SetPowerMode (END)

             ; FUNCTION CyXTAL_32KHZ_Start (BEGIN)
                                           ; SOURCE LINE # 1179
                                           ; SOURCE LINE # 1180
                                           ; SOURCE LINE # 1183
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1184
0006 904698            MOV     DPTR,#04698H
0009 7403              MOV     A,#03H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1185
000C 904309            MOV     DPTR,#04309H
000F E0                MOVX    A,@DPTR
0010 54F3              ANL     A,#0F3H
0012 4404              ORL     A,#04H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1189
0015 904308            MOV     DPTR,#04308H
0018 E0                MOVX    A,@DPTR
0019 4404              ORL     A,#04H
001B F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 75  

                                           ; SOURCE LINE # 1193
001C E0                MOVX    A,@DPTR
001D 4401              ORL     A,#01H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1195
0020 900000      R     MOV     DPTR,#i
0023 7403              MOV     A,#03H
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 74E8              MOV     A,#0E8H
0029 F0                MOVX    @DPTR,A
002A         ?C0106:
002A D3                SETB    C
002B 900000      R     MOV     DPTR,#i+01H
002E E0                MOVX    A,@DPTR
002F 9400              SUBB    A,#00H
0031 900000      R     MOV     DPTR,#i
0034 E0                MOVX    A,@DPTR
0035 9400              SUBB    A,#00H
0037 4020              JC      ?C0110
                                           ; SOURCE LINE # 1196
                                           ; SOURCE LINE # 1197
0039 120000      R     LCALL   CyXTAL_32KHZ_ReadStatus
003C EF                MOV     A,R7
003D 30E506            JNB     ACC.5,?C0109
                                           ; SOURCE LINE # 1198
                                           ; SOURCE LINE # 1200
0040 E4                CLR     A
0041 FF                MOV     R7,A
0042 120000      R     LCALL   _CyXTAL_32KHZ_SetPowerMode
                                           ; SOURCE LINE # 1202
0045 22                RET     
                                           ; SOURCE LINE # 1203
0046         ?C0109:
                                           ; SOURCE LINE # 1204
0046 7F01              MOV     R7,#01H
0048 7E00              MOV     R6,#00H
004A 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1205
004D 900000      R     MOV     DPTR,#i
0050 74FF              MOV     A,#0FFH
0052 F5F0              MOV     B,A
0054 120000      E     LCALL   ?C?IILDX
0057 80D1              SJMP    ?C0106
                                           ; SOURCE LINE # 1206
0059         ?C0110:
0059 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Start (END)

             ; FUNCTION CyXTAL_32KHZ_Stop (BEGIN)
                                           ; SOURCE LINE # 1223
                                           ; SOURCE LINE # 1224
                                           ; SOURCE LINE # 1225
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1226
0006 904698            MOV     DPTR,#04698H
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1227
000B 904309            MOV     DPTR,#04309H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 76  

000E E0                MOVX    A,@DPTR
000F 54F3              ANL     A,#0F3H
0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1229
0014 904308            MOV     DPTR,#04308H
0017 E0                MOVX    A,@DPTR
0018 54FC              ANL     A,#0FCH
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1232
001B E0                MOVX    A,@DPTR
001C 54FB              ANL     A,#0FBH
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1234
001F 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Stop (END)

             ; FUNCTION CyXTAL_32KHZ_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1254
                                           ; SOURCE LINE # 1255
                                           ; SOURCE LINE # 1256
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5420              ANL     A,#020H
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 1257
0007         ?C0112:
0007 22                RET     
             ; FUNCTION CyXTAL_32KHZ_ReadStatus (END)

             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1278
;---- Variable 'mode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1279
                                           ; SOURCE LINE # 1280
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5402              ANL     A,#02H
0006 6004              JZ      ?C0113
0008 7E01              MOV     R6,#01H
000A 8002              SJMP    ?C0114
000C         ?C0113:
000C 7E00              MOV     R6,#00H
000E         ?C0114:
000E 900000      R     MOV     DPTR,#state
0011 EE                MOV     A,R6
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1282
0013 90430A            MOV     DPTR,#0430AH
0016 74F3              MOV     A,#0F3H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1284
0019 EF                MOV     A,R7
001A 6401              XRL     A,#01H
001C 7025              JNZ     ?C0115
                                           ; SOURCE LINE # 1285
                                           ; SOURCE LINE # 1287
001E 904698            MOV     DPTR,#04698H
0021 04                INC     A
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1288
0023 7F0A              MOV     R7,#0AH
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 77  

0025 7E00              MOV     R6,#00H
0027 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1289
002A 904309            MOV     DPTR,#04309H
002D E0                MOVX    A,@DPTR
002E 54F3              ANL     A,#0F3H
0030 4408              ORL     A,#08H
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1291
0033 7F14              MOV     R7,#014H
0035 7E00              MOV     R6,#00H
0037 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1292
003A 904308            MOV     DPTR,#04308H
003D E0                MOVX    A,@DPTR
003E 4402              ORL     A,#02H
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1293
0041 801D              SJMP    ?C0116
0043         ?C0115:
                                           ; SOURCE LINE # 1295
                                           ; SOURCE LINE # 1297
0043 904698            MOV     DPTR,#04698H
0046 7406              MOV     A,#06H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1298
0049 7F0A              MOV     R7,#0AH
004B 7E00              MOV     R6,#00H
004D 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1299
0050 904309            MOV     DPTR,#04309H
0053 E0                MOVX    A,@DPTR
0054 54F3              ANL     A,#0F3H
0056 4404              ORL     A,#04H
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1301
0059 904308            MOV     DPTR,#04308H
005C E0                MOVX    A,@DPTR
005D 54FD              ANL     A,#0FDH
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1302
0060         ?C0116:
                                           ; SOURCE LINE # 1304
0060 900000      R     MOV     DPTR,#state
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
                                           ; SOURCE LINE # 1305
0065         ?C0117:
0065 22                RET     
             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (END)

             ; FUNCTION _CyXTAL_Start (BEGIN)
                                           ; SOURCE LINE # 1344
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1345
                                           ; SOURCE LINE # 1346
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#status
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1347
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 78  

0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1355
0008 904210            MOV     DPTR,#04210H
000B E0                MOVX    A,@DPTR
000C 4401              ORL     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1358
000F EF                MOV     A,R7
0010 D3                SETB    C
0011 9400              SUBB    A,#00H
0013 5003              JNC     $ + 5H
0015 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 1359
                                           ; SOURCE LINE # 1361
0018 904300            MOV     DPTR,#04300H
001B E0                MOVX    A,@DPTR
001C 900000      R     MOV     DPTR,#iloEnableState
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1362
0020 904380            MOV     DPTR,#04380H
0023 E0                MOVX    A,@DPTR
0024 900000      R     MOV     DPTR,#pmTwCfg0Tmp
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1363
0028 904382            MOV     DPTR,#04382H
002B E0                MOVX    A,@DPTR
002C 900000      R     MOV     DPTR,#pmTwCfg2Tmp
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1366
0030 7F18              MOV     R7,#018H
0032 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 1367
0035 900000      R     MOV     DPTR,#status
0038 7410              MOV     A,#010H
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1370
003B         ?C0119:
003B 900000      R     MOV     DPTR,#timeout
003E E0                MOVX    A,@DPTR
003F D3                SETB    C
0040 9400              SUBB    A,#00H
0042 403B              JC      ?C0120
                                           ; SOURCE LINE # 1371
                                           ; SOURCE LINE # 1373
0044 904210            MOV     DPTR,#04210H
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
                                           ; SOURCE LINE # 1376
0049 900000      R     MOV     DPTR,#count
004C 7404              MOV     A,#04H
004E F0                MOVX    @DPTR,A
004F         ?C0122:
004F 900000      R     MOV     DPTR,#count
0052 E0                MOVX    A,@DPTR
0053 D3                SETB    C
0054 9400              SUBB    A,#00H
0056 4011              JC      ?C0123
                                           ; SOURCE LINE # 1377
0058         ?C0125:
                                           ; SOURCE LINE # 1378
0058 7F01              MOV     R7,#01H
005A 120000      E     LCALL   _CyPmReadStatus
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 79  

005D EF                MOV     A,R7
005E 30E0F7            JNB     ACC.0,?C0125
                                           ; SOURCE LINE # 1379
                                           ; SOURCE LINE # 1381
0061         ?C0126:
                                           ; SOURCE LINE # 1382
0061         ?C0124:
0061 900000      R     MOV     DPTR,#count
0064 E0                MOVX    A,@DPTR
0065 14                DEC     A
0066 F0                MOVX    @DPTR,A
0067 80E6              SJMP    ?C0122
0069         ?C0123:
                                           ; SOURCE LINE # 1389
0069 904210            MOV     DPTR,#04210H
006C E0                MOVX    A,@DPTR
006D 5480              ANL     A,#080H
006F 7006              JNZ     ?C0121
                                           ; SOURCE LINE # 1390
                                           ; SOURCE LINE # 1391
0071 900000      R     MOV     DPTR,#status
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1392
0075 8008              SJMP    ?C0120
                                           ; SOURCE LINE # 1393
                                           ; SOURCE LINE # 1394
0077         ?C0121:
0077 900000      R     MOV     DPTR,#timeout
007A E0                MOVX    A,@DPTR
007B 14                DEC     A
007C F0                MOVX    @DPTR,A
007D 80BC              SJMP    ?C0119
007F         ?C0120:
                                           ; SOURCE LINE # 1398
007F 900000      R     MOV     DPTR,#iloEnableState
0082 E0                MOVX    A,@DPTR
0083 5404              ANL     A,#04H
0085 7003              JNZ     ?C0128
                                           ; SOURCE LINE # 1399
                                           ; SOURCE LINE # 1400
0087 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 1401
008A         ?C0128:
                                           ; SOURCE LINE # 1402
008A 900000      R     MOV     DPTR,#pmTwCfg0Tmp
008D E0                MOVX    A,@DPTR
008E 904380            MOV     DPTR,#04380H
0091 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1403
0092 900000      R     MOV     DPTR,#pmTwCfg2Tmp
0095 E0                MOVX    A,@DPTR
0096 904382            MOV     DPTR,#04382H
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1404
009A         ?C0118:
                                           ; SOURCE LINE # 1406
009A 900000      R     MOV     DPTR,#status
009D E0                MOVX    A,@DPTR
009E FF                MOV     R7,A
                                           ; SOURCE LINE # 1407
009F         ?C0129:
009F 22                RET     
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 80  

             ; FUNCTION _CyXTAL_Start (END)

             ; FUNCTION CyXTAL_Stop (BEGIN)
                                           ; SOURCE LINE # 1424
                                           ; SOURCE LINE # 1425
                                           ; SOURCE LINE # 1427
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1428
0007 22                RET     
             ; FUNCTION CyXTAL_Stop (END)

             ; FUNCTION CyXTAL_EnableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1446
                                           ; SOURCE LINE # 1447
                                           ; SOURCE LINE # 1449
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1450
0007 22                RET     
             ; FUNCTION CyXTAL_EnableErrStatus (END)

             ; FUNCTION CyXTAL_DisableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1468
                                           ; SOURCE LINE # 1469
                                           ; SOURCE LINE # 1471
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1472
0007 22                RET     
             ; FUNCTION CyXTAL_DisableErrStatus (END)

             ; FUNCTION CyXTAL_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1492
                                           ; SOURCE LINE # 1493
                                           ; SOURCE LINE # 1498
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 5480              ANL     A,#080H
0006 6004              JZ      ?C0133
0008 7F01              MOV     R7,#01H
000A 8002              SJMP    ?C0134
000C         ?C0133:
000C 7F00              MOV     R7,#00H
000E         ?C0134:
                                           ; SOURCE LINE # 1499
000E         ?C0135:
000E 22                RET     
             ; FUNCTION CyXTAL_ReadStatus (END)

             ; FUNCTION CyXTAL_EnableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1519
                                           ; SOURCE LINE # 1520
                                           ; SOURCE LINE # 1521
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 81  

0004 4440              ORL     A,#040H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1522
0007 22                RET     
             ; FUNCTION CyXTAL_EnableFaultRecovery (END)

             ; FUNCTION CyXTAL_DisableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1541
                                           ; SOURCE LINE # 1542
                                           ; SOURCE LINE # 1543
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54BF              ANL     A,#0BFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1544
0007 22                RET     
             ; FUNCTION CyXTAL_DisableFaultRecovery (END)

             ; FUNCTION _CyXTAL_SetStartup (BEGIN)
                                           ; SOURCE LINE # 1567
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1568
                                           ; SOURCE LINE # 1569
0000 EF                MOV     A,R7
0001 541F              ANL     A,#01FH
0003 FF                MOV     R7,A
0004 904212            MOV     DPTR,#04212H
0007 E0                MOVX    A,@DPTR
0008 54E0              ANL     A,#0E0H
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1571
000C 22                RET     
             ; FUNCTION _CyXTAL_SetStartup (END)

             ; FUNCTION _CyXTAL_SetFbVoltage (BEGIN)
                                           ; SOURCE LINE # 1591
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1592
                                           ; SOURCE LINE # 1593
0000 EF                MOV     A,R7
0001 540F              ANL     A,#0FH
0003 FF                MOV     R7,A
0004 904213            MOV     DPTR,#04213H
0007 E0                MOVX    A,@DPTR
0008 54F0              ANL     A,#0F0H
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1595
000C 22                RET     
             ; FUNCTION _CyXTAL_SetFbVoltage (END)

             ; FUNCTION _CyXTAL_SetWdVoltage (BEGIN)
                                           ; SOURCE LINE # 1614
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1615
                                           ; SOURCE LINE # 1617
0000 EF                MOV     A,R7
0001 C4                SWAP    A
0002 5470              ANL     A,#070H
0004 FF                MOV     R7,A
0005 904213            MOV     DPTR,#04213H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 82  

0008 E0                MOVX    A,@DPTR
0009 548F              ANL     A,#08FH
000B 4F                ORL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1618
000D 22                RET     
             ; FUNCTION _CyXTAL_SetWdVoltage (END)

             ; FUNCTION _?CyHalt (BEGIN)
                                           ; SOURCE LINE # 1635
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1637
                                           ; SOURCE LINE # 1638
                                           ; SOURCE LINE # 1640
0008         ?C0141:
                                           ; SOURCE LINE # 1647
0008 9046EA            MOV     DPTR,#046EAH
000B 7401              MOV     A,#01H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1649
000E 900001            MOV     DPTR,#01H
0011 120000      E     LCALL   ?C?ADDXBP
0014 22                RET     
             ; FUNCTION _?CyHalt (END)

             ; FUNCTION CySoftwareReset (BEGIN)
                                           ; SOURCE LINE # 1666
                                           ; SOURCE LINE # 1667
                                           ; SOURCE LINE # 1668
0000 9046F6            MOV     DPTR,#046F6H
0003 E0                MOVX    A,@DPTR
0004 4401              ORL     A,#01H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1669
0007 22                RET     
             ; FUNCTION CySoftwareReset (END)

             ; FUNCTION _?CyDelay (BEGIN)
                                           ; SOURCE LINE # 1692
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
0009         ?C0144:
                                           ; SOURCE LINE # 1694
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F 120000      E     LCALL   ?C?LLDXDATA
0012 D3                SETB    C
0013 EF                MOV     A,R7
0014 9400              SUBB    A,#00H
0016 EE                MOV     A,R6
0017 9480              SUBB    A,#080H
0019 402E              JC      ?C0145
                                           ; SOURCE LINE # 1695
                                           ; SOURCE LINE # 1700
001B 900000      R     MOV     DPTR,#cydelay_32k_ms
001E 120000      E     LCALL   ?C?LLDXDATA
0021 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1701
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 83  

0024 850083      E     MOV     DPH,?C_XBP
0027 850082      E     MOV     DPL,?C_XBP+01H
002A C083              PUSH    DPH
002C C082              PUSH    DPL
002E 120000      E     LCALL   ?C?LLDXDATA
0031 E4                CLR     A
0032 2F                ADD     A,R7
0033 FF                MOV     R7,A
0034 EE                MOV     A,R6
0035 3480              ADDC    A,#080H
0037 FE                MOV     R6,A
0038 ED                MOV     A,R5
0039 34FF              ADDC    A,#0FFH
003B FD                MOV     R5,A
003C EC                MOV     A,R4
003D 34FF              ADDC    A,#0FFH
003F FC                MOV     R4,A
0040 D082              POP     DPL
0042 D083              POP     DPH
0044 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1702
0047 80C0              SJMP    ?C0144
0049         ?C0145:
                                           ; SOURCE LINE # 1704
0049 900000      R     MOV     DPTR,#cydelay_freq_khz
004C 120000      E     LCALL   ?C?LLDXDATA
004F 850083      E     MOV     DPH,?C_XBP
0052 850082      E     MOV     DPL,?C_XBP+01H
0055 120000      E     LCALL   ?C?LLDXDATA0
0058 120000      E     LCALL   ?C?LMUL
005B 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1705
005E 900004            MOV     DPTR,#04H
0061 120000      E     LCALL   ?C?ADDXBP
0064 22                RET     
             ; FUNCTION _?CyDelay (END)

             ; FUNCTION _?CyDelayFreq (BEGIN)
                                           ; SOURCE LINE # 1763
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1765
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F 120000      E     LCALL   ?C?LLDXDATA
0012 EF                MOV     A,R7
0013 4E                ORL     A,R6
0014 6011              JZ      ?C0147
                                           ; SOURCE LINE # 1766
                                           ; SOURCE LINE # 1767
0016 850083      E     MOV     DPH,?C_XBP
0019 850082      E     MOV     DPL,?C_XBP+01H
001C 120000      E     LCALL   ?C?LLDXDATA
001F 900000      R     MOV     DPTR,#cydelay_freq_hz
0022 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1768
0025 800E              SJMP    ?C0148
0027         ?C0147:
                                           ; SOURCE LINE # 1770
                                           ; SOURCE LINE # 1771
0027 7F00              MOV     R7,#00H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 84  

0029 7E36              MOV     R6,#036H
002B 7D6E              MOV     R5,#06EH
002D 7C01              MOV     R4,#01H
002F 900000      R     MOV     DPTR,#cydelay_freq_hz
0032 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1772
0035         ?C0148:
                                           ; SOURCE LINE # 1774
0035 900000      R     MOV     DPTR,#cydelay_freq_hz
0038 120000      E     LCALL   ?C?LLDXDATA
003B EF                MOV     A,R7
003C 243F              ADD     A,#03FH
003E FF                MOV     R7,A
003F EE                MOV     A,R6
0040 3442              ADDC    A,#042H
0042 FE                MOV     R6,A
0043 ED                MOV     A,R5
0044 340F              ADDC    A,#0FH
0046 FD                MOV     R5,A
0047 E4                CLR     A
0048 3C                ADDC    A,R4
0049 FC                MOV     R4,A
004A 7B40              MOV     R3,#040H
004C 7A42              MOV     R2,#042H
004E 790F              MOV     R1,#0FH
0050 7800              MOV     R0,#00H
0052 120000      E     LCALL   ?C?ULDIV
0055 900000      R     MOV     DPTR,#cydelay_freq_mhz
0058 EF                MOV     A,R7
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1775
005A A3                INC     DPTR
005B 120000      E     LCALL   ?C?LLDXDATA
005E EF                MOV     A,R7
005F 24E7              ADD     A,#0E7H
0061 FF                MOV     R7,A
0062 EE                MOV     A,R6
0063 3403              ADDC    A,#03H
0065 FE                MOV     R6,A
0066 E4                CLR     A
0067 3D                ADDC    A,R5
0068 FD                MOV     R5,A
0069 E4                CLR     A
006A 3C                ADDC    A,R4
006B FC                MOV     R4,A
006C E4                CLR     A
006D 7BE8              MOV     R3,#0E8H
006F 7A03              MOV     R2,#03H
0071 F9                MOV     R1,A
0072 F8                MOV     R0,A
0073 120000      E     LCALL   ?C?ULDIV
0076 900000      R     MOV     DPTR,#cydelay_freq_khz
0079 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1776
007C E4                CLR     A
007D FF                MOV     R7,A
007E 7E80              MOV     R6,#080H
0080 FD                MOV     R5,A
0081 FC                MOV     R4,A
0082 900000      R     MOV     DPTR,#cydelay_freq_khz
0085 120000      E     LCALL   ?C?LLDXDATA0
0088 120000      E     LCALL   ?C?LMUL
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 85  

008B 900000      R     MOV     DPTR,#cydelay_32k_ms
008E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1777
0091 900004            MOV     DPTR,#04H
0094 120000      E     LCALL   ?C?ADDXBP
0097 22                RET     
             ; FUNCTION _?CyDelayFreq (END)

             ; FUNCTION _CyWdtStart (BEGIN)
                                           ; SOURCE LINE # 1826
;---- Variable 'lpMode' assigned to Register 'R5' ----
;---- Variable 'ticks' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1827
                                           ; SOURCE LINE # 1829
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904383            MOV     DPTR,#04383H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1832
000C E0                MOVX    A,@DPTR
000D 4480              ORL     A,#080H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1833
0010 E0                MOVX    A,@DPTR
0011 547F              ANL     A,#07FH
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1837
0014 AF05              MOV     R7,AR5
0016 EF                MOV     A,R7
0017 C4                SWAP    A
0018 33                RLC     A
0019 5460              ANL     A,#060H
001B FF                MOV     R7,A
001C E0                MOVX    A,@DPTR
001D 549F              ANL     A,#09FH
001F 4F                ORL     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1840
0021 E0                MOVX    A,@DPTR
0022 4410              ORL     A,#010H
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1841
0025 22                RET     
             ; FUNCTION _CyWdtStart (END)

             ; FUNCTION CyWdtClear (BEGIN)
                                           ; SOURCE LINE # 1858
                                           ; SOURCE LINE # 1859
                                           ; SOURCE LINE # 1860
0000 904384            MOV     DPTR,#04384H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1861
0006 22                RET     
             ; FUNCTION CyWdtClear (END)

             ; FUNCTION _CyVdLvDigitEnable (BEGIN)
                                           ; SOURCE LINE # 1907
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 86  

0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1908
                                           ; SOURCE LINE # 1912
0008 120000      E     LCALL   CyEnterCriticalSection
000B 900000      R     MOV     DPTR,#interruptState
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1915
0010 9044C0            MOV     DPTR,#044C0H
0013 E0                MOVX    A,@DPTR
0014 5401              ANL     A,#01H
0016 FF                MOV     R7,A
0017 E4                CLR     A
0018 FC                MOV     R4,A
0019 FD                MOV     R5,A
001A FE                MOV     R6,A
001B 900000      R     MOV     DPTR,#intRegTmp
001E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1918
0021 9044C8            MOV     DPTR,#044C8H
0024 7401              MOV     A,#01H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1920
0027 9046F7            MOV     DPTR,#046F7H
002A E0                MOVX    A,@DPTR
002B 54BF              ANL     A,#0BFH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1923
002E 9046F4            MOV     DPTR,#046F4H
0031 E0                MOVX    A,@DPTR
0032 54F0              ANL     A,#0F0H
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#threshold
0038 E0                MOVX    A,@DPTR
0039 540F              ANL     A,#0FH
003B 4F                ORL     A,R7
003C 9046F4            MOV     DPTR,#046F4H
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1924
0040 A3                INC     DPTR
0041 E0                MOVX    A,@DPTR
0042 4401              ORL     A,#01H
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1927
0045 7F01              MOV     R7,#01H
0047 7E00              MOV     R6,#00H
0049 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1929
004C 7F01              MOV     R7,#01H
004E 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 1931
0051 900000      R     MOV     DPTR,#reset
0054 E0                MOVX    A,@DPTR
0055 6009              JZ      ?C0152
                                           ; SOURCE LINE # 1932
                                           ; SOURCE LINE # 1933
0057 9046F7            MOV     DPTR,#046F7H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 87  

005A E0                MOVX    A,@DPTR
005B 4440              ORL     A,#040H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1934
005E 8007              SJMP    ?C0153
0060         ?C0152:
                                           ; SOURCE LINE # 1936
                                           ; SOURCE LINE # 1937
0060 9046F7            MOV     DPTR,#046F7H
0063 E0                MOVX    A,@DPTR
0064 54BF              ANL     A,#0BFH
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1938
0067         ?C0153:
                                           ; SOURCE LINE # 1941
0067 9044D8            MOV     DPTR,#044D8H
006A 7401              MOV     A,#01H
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1944
006D 900000      R     MOV     DPTR,#intRegTmp
0070 120000      E     LCALL   ?C?LLDXDATA
0073 9044C0            MOV     DPTR,#044C0H
0076 EF                MOV     A,R7
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1946
0078 900000      R     MOV     DPTR,#interruptState
007B E0                MOVX    A,@DPTR
007C FF                MOV     R7,A
007D 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1947
0080 22                RET     
             ; FUNCTION _CyVdLvDigitEnable (END)

             ; FUNCTION _CyVdLvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 1992
0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1993
                                           ; SOURCE LINE # 1997
0008 120000      E     LCALL   CyEnterCriticalSection
000B 900000      R     MOV     DPTR,#interruptState
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2000
0010 9044C0            MOV     DPTR,#044C0H
0013 E0                MOVX    A,@DPTR
0014 5401              ANL     A,#01H
0016 FF                MOV     R7,A
0017 E4                CLR     A
0018 FC                MOV     R4,A
0019 FD                MOV     R5,A
001A FE                MOV     R6,A
001B 900000      R     MOV     DPTR,#intRegTmp
001E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2003
0021 9044C8            MOV     DPTR,#044C8H
0024 7401              MOV     A,#01H
0026 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 88  

                                           ; SOURCE LINE # 2005
0027 9046F7            MOV     DPTR,#046F7H
002A E0                MOVX    A,@DPTR
002B 547F              ANL     A,#07FH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2007
002E 900000      R     MOV     DPTR,#threshold
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 C4                SWAP    A
0034 54F0              ANL     A,#0F0H
0036 FF                MOV     R7,A
0037 9046F4            MOV     DPTR,#046F4H
003A E0                MOVX    A,@DPTR
003B 540F              ANL     A,#0FH
003D 4F                ORL     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2008
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 4402              ORL     A,#02H
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2011
0044 7F01              MOV     R7,#01H
0046 7E00              MOV     R6,#00H
0048 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 2013
004B 7F02              MOV     R7,#02H
004D 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 2015
0050 900000      R     MOV     DPTR,#reset
0053 E0                MOVX    A,@DPTR
0054 6009              JZ      ?C0155
                                           ; SOURCE LINE # 2016
                                           ; SOURCE LINE # 2017
0056 9046F7            MOV     DPTR,#046F7H
0059 E0                MOVX    A,@DPTR
005A 4480              ORL     A,#080H
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2018
005D 8007              SJMP    ?C0156
005F         ?C0155:
                                           ; SOURCE LINE # 2020
                                           ; SOURCE LINE # 2021
005F 9046F7            MOV     DPTR,#046F7H
0062 E0                MOVX    A,@DPTR
0063 547F              ANL     A,#07FH
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2022
0066         ?C0156:
                                           ; SOURCE LINE # 2025
0066 9044D8            MOV     DPTR,#044D8H
0069 7401              MOV     A,#01H
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2028
006C 900000      R     MOV     DPTR,#intRegTmp
006F 120000      E     LCALL   ?C?LLDXDATA
0072 9044C0            MOV     DPTR,#044C0H
0075 EF                MOV     A,R7
0076 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2030
0077 900000      R     MOV     DPTR,#interruptState
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 89  

007A E0                MOVX    A,@DPTR
007B FF                MOV     R7,A
007C 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2031
007F 22                RET     
             ; FUNCTION _CyVdLvAnalogEnable (END)

             ; FUNCTION CyVdLvDigitDisable (BEGIN)
                                           ; SOURCE LINE # 2053
                                           ; SOURCE LINE # 2054
                                           ; SOURCE LINE # 2055
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2056
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 54BF              ANL     A,#0BFH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2057
000E 7F01              MOV     R7,#01H
0010 120000      R     LCALL   _CyVdStickyStatus
0013         ?C0158:
                                           ; SOURCE LINE # 2059
0013 7F01              MOV     R7,#01H
0015 120000      R     LCALL   _CyVdStickyStatus
0018 EF                MOV     A,R7
0019 20E0F7            JB      ACC.0,?C0158
                                           ; SOURCE LINE # 2060
                                           ; SOURCE LINE # 2062
001C         ?C0159:
                                           ; SOURCE LINE # 2063
001C         ?C0160:
001C 22                RET     
             ; FUNCTION CyVdLvDigitDisable (END)

             ; FUNCTION CyVdLvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 2085
                                           ; SOURCE LINE # 2086
                                           ; SOURCE LINE # 2087
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2088
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 547F              ANL     A,#07FH
000D F0                MOVX    @DPTR,A
000E         ?C0161:
                                           ; SOURCE LINE # 2089
000E 7F02              MOV     R7,#02H
0010 120000      R     LCALL   _CyVdStickyStatus
0013 EF                MOV     A,R7
0014 20E1F7            JB      ACC.1,?C0161
                                           ; SOURCE LINE # 2090
                                           ; SOURCE LINE # 2092
0017         ?C0162:
                                           ; SOURCE LINE # 2093
0017         ?C0163:
0017 22                RET     
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 90  

             ; FUNCTION CyVdLvAnalogDisable (END)

             ; FUNCTION CyVdHvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 2115
                                           ; SOURCE LINE # 2116
                                           ; SOURCE LINE # 2120
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2123
0008 9044C0            MOV     DPTR,#044C0H
000B E0                MOVX    A,@DPTR
000C 5401              ANL     A,#01H
000E FF                MOV     R7,A
000F E4                CLR     A
0010 FC                MOV     R4,A
0011 FD                MOV     R5,A
0012 FE                MOV     R6,A
0013 900000      R     MOV     DPTR,#intRegTmp
0016 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2126
0019 9044C8            MOV     DPTR,#044C8H
001C 7401              MOV     A,#01H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2128
001F 9046F7            MOV     DPTR,#046F7H
0022 E0                MOVX    A,@DPTR
0023 547F              ANL     A,#07FH
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2130
0026 9046F5            MOV     DPTR,#046F5H
0029 E0                MOVX    A,@DPTR
002A 4404              ORL     A,#04H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2133
002D 7F01              MOV     R7,#01H
002F 7E00              MOV     R6,#00H
0031 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 2135
0034 7F04              MOV     R7,#04H
0036 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 2138
0039 9044D8            MOV     DPTR,#044D8H
003C 7401              MOV     A,#01H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2141
003F 900000      R     MOV     DPTR,#intRegTmp
0042 120000      E     LCALL   ?C?LLDXDATA
0045 9044C0            MOV     DPTR,#044C0H
0048 EF                MOV     A,R7
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2143
004A 900000      R     MOV     DPTR,#interruptState
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2144
0052 22                RET     
             ; FUNCTION CyVdHvAnalogEnable (END)

             ; FUNCTION CyVdHvAnalogDisable (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 91  

                                           ; SOURCE LINE # 2166
                                           ; SOURCE LINE # 2167
                                           ; SOURCE LINE # 2168
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
0007         ?C0165:
                                           ; SOURCE LINE # 2169
0007 7F04              MOV     R7,#04H
0009 120000      R     LCALL   _CyVdStickyStatus
000C EF                MOV     A,R7
000D 20E2F7            JB      ACC.2,?C0165
                                           ; SOURCE LINE # 2170
                                           ; SOURCE LINE # 2172
0010         ?C0166:
                                           ; SOURCE LINE # 2173
0010         ?C0167:
0010 22                RET     
             ; FUNCTION CyVdHvAnalogDisable (END)

             ; FUNCTION _CyVdStickyStatus (BEGIN)
                                           ; SOURCE LINE # 2204
0000 900000      R     MOV     DPTR,#mask
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2205
                                           ; SOURCE LINE # 2210
0005 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R5' ----
0008 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 2212
000A 900000      R     MOV     DPTR,#interruptStatus
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F 9046FA            MOV     DPTR,#046FAH
0012 E0                MOVX    A,@DPTR
0013 FE                MOV     R6,A
0014 EF                MOV     A,R7
0015 4E                ORL     A,R6
0016 900000      R     MOV     DPTR,#interruptStatus
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2213
001A E0                MOVX    A,@DPTR
001B FC                MOV     R4,A
001C 5407              ANL     A,#07H
001E 900000      R     MOV     DPTR,#tmpStatus
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2214
0022 900000      R     MOV     DPTR,#mask
0025 E0                MOVX    A,@DPTR
0026 F4                CPL     A
0027 FF                MOV     R7,A
0028 EC                MOV     A,R4
0029 5F                ANL     A,R7
002A 900000      R     MOV     DPTR,#interruptStatus
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2216
002E AF05              MOV     R7,AR5
0030 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2218
0033 900000      R     MOV     DPTR,#tmpStatus
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 92  

0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
                                           ; SOURCE LINE # 2219
0038         ?C0168:
0038 22                RET     
             ; FUNCTION _CyVdStickyStatus (END)

             ; FUNCTION CyVdRealTimeStatus (BEGIN)
                                           ; SOURCE LINE # 2248
                                           ; SOURCE LINE # 2249
                                           ; SOURCE LINE # 2253
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R5' ----
0003 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 2254
0005 9046FC            MOV     DPTR,#046FCH
0008 E0                MOVX    A,@DPTR
0009 5407              ANL     A,#07H
000B 900000      R     MOV     DPTR,#vdFlagsState
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2255
000F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2257
0012 900000      R     MOV     DPTR,#vdFlagsState
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
                                           ; SOURCE LINE # 2258
0017         ?C0169:
0017 22                RET     
             ; FUNCTION CyVdRealTimeStatus (END)

             ; FUNCTION CyDisableInts (BEGIN)
                                           ; SOURCE LINE # 2275
                                           ; SOURCE LINE # 2276
                                           ; SOURCE LINE # 2280
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2285
0008 9044C8            MOV     DPTR,#044C8H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D E4                CLR     A
000E FC                MOV     R4,A
000F FD                MOV     R5,A
0010 FE                MOV     R6,A
0011 900000      R     MOV     DPTR,#intState
0014 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2286
0017 900000      R     MOV     DPTR,#intState
001A 120000      E     LCALL   ?C?LLDXDATA0
001D C000              PUSH    AR0
001F 9044C9            MOV     DPTR,#044C9H
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E4                CLR     A
0025 FC                MOV     R4,A
0026 FD                MOV     R5,A
0027 FE                MOV     R6,A
0028 7808              MOV     R0,#08H
002A 120000      E     LCALL   ?C?LSHL
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 93  

002D D000              POP     AR0
002F 120000      E     LCALL   ?C?LOR
0032 900000      R     MOV     DPTR,#intState
0035 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2287
0038 900000      R     MOV     DPTR,#intState
003B 120000      E     LCALL   ?C?LLDXDATA0
003E C000              PUSH    AR0
0040 9044CA            MOV     DPTR,#044CAH
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 E4                CLR     A
0046 FC                MOV     R4,A
0047 FD                MOV     R5,A
0048 FE                MOV     R6,A
0049 7810              MOV     R0,#010H
004B 120000      E     LCALL   ?C?LSHL
004E D000              POP     AR0
0050 120000      E     LCALL   ?C?LOR
0053 900000      R     MOV     DPTR,#intState
0056 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2288
0059 900000      R     MOV     DPTR,#intState
005C 120000      E     LCALL   ?C?LLDXDATA0
005F C000              PUSH    AR0
0061 9044CB            MOV     DPTR,#044CBH
0064 E0                MOVX    A,@DPTR
0065 FF                MOV     R7,A
0066 E4                CLR     A
0067 FC                MOV     R4,A
0068 FD                MOV     R5,A
0069 FE                MOV     R6,A
006A 7818              MOV     R0,#018H
006C 120000      E     LCALL   ?C?LSHL
006F D000              POP     AR0
0071 120000      E     LCALL   ?C?LOR
0074 900000      R     MOV     DPTR,#intState
0077 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2292
007A 9044C8            MOV     DPTR,#044C8H
007D 74FF              MOV     A,#0FFH
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2293
0080 A3                INC     DPTR
0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2294
0082 A3                INC     DPTR
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2295
0084 A3                INC     DPTR
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2307
0086 900000      R     MOV     DPTR,#interruptState
0089 E0                MOVX    A,@DPTR
008A FF                MOV     R7,A
008B 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2309
008E 900000      R     MOV     DPTR,#intState
0091 120000      E     LCALL   ?C?LLDXDATA
                                           ; SOURCE LINE # 2310
0094         ?C0170:
0094 22                RET     
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 94  

             ; FUNCTION CyDisableInts (END)

             ; FUNCTION _CyEnableInts (BEGIN)
                                           ; SOURCE LINE # 2327
0000 900000      R     MOV     DPTR,#mask
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2328
                                           ; SOURCE LINE # 2332
0006 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R3' ----
0009 AB07              MOV     R3,AR7
                                           ; SOURCE LINE # 2337
000B 900000      R     MOV     DPTR,#mask
000E 120000      E     LCALL   ?C?LLDXDATA
0011 7818              MOV     R0,#018H
0013 120000      E     LCALL   ?C?ULSHR
0016 9044C3            MOV     DPTR,#044C3H
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2338
001B 900000      R     MOV     DPTR,#mask
001E 120000      E     LCALL   ?C?LLDXDATA
0021 7810              MOV     R0,#010H
0023 120000      E     LCALL   ?C?ULSHR
0026 9044C2            MOV     DPTR,#044C2H
0029 EF                MOV     A,R7
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2339
002B 900000      R     MOV     DPTR,#mask
002E 120000      E     LCALL   ?C?LLDXDATA
0031 7808              MOV     R0,#08H
0033 120000      E     LCALL   ?C?ULSHR
0036 9044C1            MOV     DPTR,#044C1H
0039 EF                MOV     A,R7
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2340
003B 900000      R     MOV     DPTR,#mask
003E 120000      E     LCALL   ?C?LLDXDATA
0041 9044C0            MOV     DPTR,#044C0H
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2348
0046 AF03              MOV     R7,AR3
0048 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2350
004B 22                RET     
             ; FUNCTION _CyEnableInts (END)

             ; FUNCTION _CyIntSetVector (BEGIN)
                                           ; SOURCE LINE # 2641
0000 900000      R     MOV     DPTR,#address
0003 EC                MOV     A,R4
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 900000      R     MOV     DPTR,#number
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2642
                                           ; SOURCE LINE # 2643
                                           ; SOURCE LINE # 2645
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 95  

000D D3                SETB    C
000E 941F              SUBB    A,#01FH
0010 5002              JNC     ?C0173
0012 8001              SJMP    ?C0174
0014         ?C0173:
0014 C3                CLR     C
0015         ?C0174:
0015 4005              JC      ?C0172
0017 7F00              MOV     R7,#00H
0019 120000      R     LCALL   _?CyHalt
001C         ?C0172:
                                           ; SOURCE LINE # 2648
001C 900000      R     MOV     DPTR,#number
001F E0                MOVX    A,@DPTR
0020 541F              ANL     A,#01FH
0022 25E0              ADD     A,ACC
0024 FF                MOV     R7,A
0025 E4                CLR     A
0026 33                RLC     A
0027 FE                MOV     R6,A
0028 E4                CLR     A
0029 2F                ADD     A,R7
002A FF                MOV     R7,A
002B EE                MOV     A,R6
002C 3444              ADDC    A,#044H
002E FA                MOV     R2,A
002F A907              MOV     R1,AR7
0031 7B01              MOV     R3,#01H
0033 120000      E     LCALL   _cyread16_nodpx
0036 900000      R     MOV     DPTR,#oldIsr
0039 EE                MOV     A,R6
003A F0                MOVX    @DPTR,A
003B A3                INC     DPTR
003C EF                MOV     A,R7
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2652
003E 900000      R     MOV     DPTR,#number
0041 E0                MOVX    A,@DPTR
0042 75F002            MOV     B,#02H
0045 A4                MUL     AB
0046 2400              ADD     A,#00H
0048 FF                MOV     R7,A
0049 E5F0              MOV     A,B
004B 3444              ADDC    A,#044H
004D FA                MOV     R2,A
004E A907              MOV     R1,AR7
0050 7B01              MOV     R3,#01H
0052 A3                INC     DPTR
0053 E0                MOVX    A,@DPTR
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 FD                MOV     R5,A
0059 AC06              MOV     R4,AR6
005B 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 2654
005E 900000      R     MOV     DPTR,#oldIsr
0061 E0                MOVX    A,@DPTR
0062 FE                MOV     R6,A
0063 A3                INC     DPTR
0064 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 96  

0065 FF                MOV     R7,A
                                           ; SOURCE LINE # 2655
0066         ?C0175:
0066 22                RET     
             ; FUNCTION _CyIntSetVector (END)

             ; FUNCTION _CyIntGetVector (BEGIN)
                                           ; SOURCE LINE # 2672
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2673
                                           ; SOURCE LINE # 2674
0005 D3                SETB    C
0006 941F              SUBB    A,#01FH
0008 5002              JNC     ?C0177
000A 8001              SJMP    ?C0178
000C         ?C0177:
000C C3                CLR     C
000D         ?C0178:
000D 4005              JC      ?C0176
000F 7F00              MOV     R7,#00H
0011 120000      R     LCALL   _?CyHalt
0014         ?C0176:
                                           ; SOURCE LINE # 2676
0014 900000      R     MOV     DPTR,#number
0017 E0                MOVX    A,@DPTR
0018 541F              ANL     A,#01FH
001A 25E0              ADD     A,ACC
001C FF                MOV     R7,A
001D E4                CLR     A
001E 33                RLC     A
001F FE                MOV     R6,A
0020 E4                CLR     A
0021 2F                ADD     A,R7
0022 FF                MOV     R7,A
0023 EE                MOV     A,R6
0024 3444              ADDC    A,#044H
0026 FA                MOV     R2,A
0027 A907              MOV     R1,AR7
0029 7B01              MOV     R3,#01H
002B 120000      E     LCALL   _cyread16_nodpx
                                           ; SOURCE LINE # 2678
002E         ?C0179:
002E 22                RET     
             ; FUNCTION _CyIntGetVector (END)

             ; FUNCTION _CyIntSetPriority (BEGIN)
                                           ; SOURCE LINE # 2696
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2697
                                           ; SOURCE LINE # 2698
0008 D3                SETB    C
0009 9407              SUBB    A,#07H
000B 5002              JNC     ?C0181
000D 8001              SJMP    ?C0182
000F         ?C0181:
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 97  

000F C3                CLR     C
0010         ?C0182:
0010 4005              JC      ?C0180
0012 7F00              MOV     R7,#00H
0014 120000      R     LCALL   _?CyHalt
0017         ?C0180:
                                           ; SOURCE LINE # 2700
0017 900000      R     MOV     DPTR,#number
001A E0                MOVX    A,@DPTR
001B D3                SETB    C
001C 941F              SUBB    A,#01FH
001E 5002              JNC     ?C0184
0020 8001              SJMP    ?C0185
0022         ?C0184:
0022 C3                CLR     C
0023         ?C0185:
0023 4005              JC      ?C0183
0025 7F00              MOV     R7,#00H
0027 120000      R     LCALL   _?CyHalt
002A         ?C0183:
                                           ; SOURCE LINE # 2702
002A 900000      R     MOV     DPTR,#priority
002D E0                MOVX    A,@DPTR
002E 5407              ANL     A,#07H
0030 75F020            MOV     B,#020H
0033 A4                MUL     AB
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#number
0038 E0                MOVX    A,@DPTR
0039 541F              ANL     A,#01FH
003B 2480              ADD     A,#080H
003D F582              MOV     DPL,A
003F E4                CLR     A
0040 3444              ADDC    A,#044H
0042 F583              MOV     DPH,A
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2704
0046 22                RET     
             ; FUNCTION _CyIntSetPriority (END)

             ; FUNCTION _CyIntGetPriority (BEGIN)
                                           ; SOURCE LINE # 2721
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2722
                                           ; SOURCE LINE # 2723
                                           ; SOURCE LINE # 2725
0005 D3                SETB    C
0006 941F              SUBB    A,#01FH
0008 5002              JNC     ?C0188
000A 8001              SJMP    ?C0189
000C         ?C0188:
000C C3                CLR     C
000D         ?C0189:
000D 4005              JC      ?C0187
000F 7F00              MOV     R7,#00H
0011 120000      R     LCALL   _?CyHalt
0014         ?C0187:
                                           ; SOURCE LINE # 2727
0014 900000      R     MOV     DPTR,#number
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 98  

0017 E0                MOVX    A,@DPTR
0018 541F              ANL     A,#01FH
001A 2480              ADD     A,#080H
001C F582              MOV     DPL,A
001E E4                CLR     A
001F 3444              ADDC    A,#044H
0021 F583              MOV     DPH,A
0023 E0                MOVX    A,@DPTR
0024 FF                MOV     R7,A
0025 C4                SWAP    A
0026 13                RRC     A
0027 5407              ANL     A,#07H
0029 FF                MOV     R7,A
;---- Variable 'priority' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2729
                                           ; SOURCE LINE # 2730
002A         ?C0190:
002A 22                RET     
             ; FUNCTION _CyIntGetPriority (END)

             ; FUNCTION _CyIntGetState (BEGIN)
                                           ; SOURCE LINE # 2747
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2748
                                           ; SOURCE LINE # 2749
                                           ; SOURCE LINE # 2751
0005 D3                SETB    C
0006 941F              SUBB    A,#01FH
0008 5002              JNC     ?C0192
000A 8001              SJMP    ?C0193
000C         ?C0192:
000C C3                CLR     C
000D         ?C0193:
000D 4005              JC      ?C0191
000F 7F00              MOV     R7,#00H
0011 120000      R     LCALL   _?CyHalt
0014         ?C0191:
                                           ; SOURCE LINE # 2754
0014 900000      R     MOV     DPTR,#number
0017 E0                MOVX    A,@DPTR
0018 FD                MOV     R5,A
0019 541F              ANL     A,#01FH
001B 7E00              MOV     R6,#00H
001D 7803              MOV     R0,#03H
001F         ?C0199:
001F CE                XCH     A,R6
0020 C3                CLR     C
0021 13                RRC     A
0022 CE                XCH     A,R6
0023 13                RRC     A
0024 D8F9              DJNZ    R0,?C0199
0026 24C0              ADD     A,#0C0H
0028 FF                MOV     R7,A
0029 EE                MOV     A,R6
002A 3444              ADDC    A,#044H
002C FE                MOV     R6,A
;---- Variable 'stateReg' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 2757
002D ED                MOV     A,R5
002E 5407              ANL     A,#07H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 99  

0030 FD                MOV     R5,A
0031 7401              MOV     A,#01H
0033 A805              MOV     R0,AR5
0035 08                INC     R0
0036 8002              SJMP    ?C0201
0038         ?C0200:
0038 C3                CLR     C
0039 33                RLC     A
003A         ?C0201:
003A D8FC              DJNZ    R0,?C0200
003C FD                MOV     R5,A
003D 8F82              MOV     DPL,R7
003F 8E83              MOV     DPH,R6
0041 E0                MOVX    A,@DPTR
0042 5D                ANL     A,R5
0043 6004              JZ      ?C0194
0045 7F01              MOV     R7,#01H
0047 8002              SJMP    ?C0195
0049         ?C0194:
0049 7F00              MOV     R7,#00H
004B         ?C0195:
                                           ; SOURCE LINE # 2758
004B         ?C0196:
004B 22                RET     
             ; FUNCTION _CyIntGetState (END)

             ; FUNCTION _CyGetUniqueId (BEGIN)
                                           ; SOURCE LINE # 3278
0000 900000      R     MOV     DPTR,#uniqueId
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 3279
                                           ; SOURCE LINE # 3291
0006 7B0C              MOV     R3,#0CH
0008 7A01              MOV     R2,#01H
000A 7903              MOV     R1,#03H
000C 120000      E     LCALL   _cyread8
000F E4                CLR     A
0010 FC                MOV     R4,A
0011 FD                MOV     R5,A
0012 FE                MOV     R6,A
0013 900000      R     MOV     DPTR,#uniqueId
0016 120000      E     LCALL   ?C?PLDXDATA
0019 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3292
001C 900000      R     MOV     DPTR,#uniqueId
001F 120000      E     LCALL   ?C?PLDXDATA
0022 C003              PUSH    AR3
0024 C002              PUSH    AR2
0026 C001              PUSH    AR1
0028 120000      E     LCALL   ?C?LLDPTR
002B C004              PUSH    AR4
002D C005              PUSH    AR5
002F C006              PUSH    AR6
0031 C007              PUSH    AR7
0033 7B0C              MOV     R3,#0CH
0035 7A01              MOV     R2,#01H
0037 7904              MOV     R1,#04H
0039 120000      E     LCALL   _cyread8
003C E4                CLR     A
003D FC                MOV     R4,A
003E FD                MOV     R5,A
003F FE                MOV     R6,A
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 100 

0040 7808              MOV     R0,#08H
0042 120000      E     LCALL   ?C?LSHL
0045 A804              MOV     R0,AR4
0047 A905              MOV     R1,AR5
0049 AA06              MOV     R2,AR6
004B AB07              MOV     R3,AR7
004D D007              POP     AR7
004F D006              POP     AR6
0051 D005              POP     AR5
0053 D004              POP     AR4
0055 120000      E     LCALL   ?C?LOR
0058 D001              POP     AR1
005A D002              POP     AR2
005C D003              POP     AR3
005E 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3293
0061 900000      R     MOV     DPTR,#uniqueId
0064 120000      E     LCALL   ?C?PLDXDATA
0067 C003              PUSH    AR3
0069 C002              PUSH    AR2
006B C001              PUSH    AR1
006D 120000      E     LCALL   ?C?LLDPTR
0070 C004              PUSH    AR4
0072 C005              PUSH    AR5
0074 C006              PUSH    AR6
0076 C007              PUSH    AR7
0078 7B00              MOV     R3,#00H
007A 7A46              MOV     R2,#046H
007C 79EC              MOV     R1,#0ECH
007E 120000      E     LCALL   _cyread8
0081 E4                CLR     A
0082 FC                MOV     R4,A
0083 FD                MOV     R5,A
0084 FE                MOV     R6,A
0085 7810              MOV     R0,#010H
0087 120000      E     LCALL   ?C?LSHL
008A A804              MOV     R0,AR4
008C A905              MOV     R1,AR5
008E AA06              MOV     R2,AR6
0090 AB07              MOV     R3,AR7
0092 D007              POP     AR7
0094 D006              POP     AR6
0096 D005              POP     AR5
0098 D004              POP     AR4
009A 120000      E     LCALL   ?C?LOR
009D D001              POP     AR1
009F D002              POP     AR2
00A1 D003              POP     AR3
00A3 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3294
00A6 900000      R     MOV     DPTR,#uniqueId
00A9 120000      E     LCALL   ?C?PLDXDATA
00AC C003              PUSH    AR3
00AE C002              PUSH    AR2
00B0 C001              PUSH    AR1
00B2 120000      E     LCALL   ?C?LLDPTR
00B5 C004              PUSH    AR4
00B7 C005              PUSH    AR5
00B9 C006              PUSH    AR6
00BB C007              PUSH    AR7
00BD 7B0C              MOV     R3,#0CH
00BF 7A01              MOV     R2,#01H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 101 

00C1 7902              MOV     R1,#02H
00C3 120000      E     LCALL   _cyread8
00C6 E4                CLR     A
00C7 FC                MOV     R4,A
00C8 FD                MOV     R5,A
00C9 FE                MOV     R6,A
00CA 7818              MOV     R0,#018H
00CC 120000      E     LCALL   ?C?LSHL
00CF A804              MOV     R0,AR4
00D1 A905              MOV     R1,AR5
00D3 AA06              MOV     R2,AR6
00D5 AB07              MOV     R3,AR7
00D7 D007              POP     AR7
00D9 D006              POP     AR6
00DB D005              POP     AR5
00DD D004              POP     AR4
00DF 120000      E     LCALL   ?C?LOR
00E2 D001              POP     AR1
00E4 D002              POP     AR2
00E6 D003              POP     AR3
00E8 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3296
00EB 7B0C              MOV     R3,#0CH
00ED 7A01              MOV     R2,#01H
00EF 7901              MOV     R1,#01H
00F1 120000      E     LCALL   _cyread8
00F4 E4                CLR     A
00F5 FC                MOV     R4,A
00F6 FD                MOV     R5,A
00F7 FE                MOV     R6,A
00F8 900000      R     MOV     DPTR,#uniqueId
00FB 120000      E     LCALL   ?C?PLDXDATA
00FE E9                MOV     A,R1
00FF 2404              ADD     A,#04H
0101 F9                MOV     R1,A
0102 E4                CLR     A
0103 3A                ADDC    A,R2
0104 FA                MOV     R2,A
0105 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3297
0108 900000      R     MOV     DPTR,#uniqueId
010B 120000      E     LCALL   ?C?PLDXDATA
010E E9                MOV     A,R1
010F 2404              ADD     A,#04H
0111 F9                MOV     R1,A
0112 E4                CLR     A
0113 3A                ADDC    A,R2
0114 FA                MOV     R2,A
0115 C003              PUSH    AR3
0117 C002              PUSH    AR2
0119 C001              PUSH    AR1
011B 120000      E     LCALL   ?C?LLDPTR
011E C004              PUSH    AR4
0120 C005              PUSH    AR5
0122 C006              PUSH    AR6
0124 C007              PUSH    AR7
0126 7B0C              MOV     R3,#0CH
0128 7A01              MOV     R2,#01H
012A 7900              MOV     R1,#00H
012C 120000      E     LCALL   _cyread8
012F E4                CLR     A
0130 FC                MOV     R4,A
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 102 

0131 FD                MOV     R5,A
0132 FE                MOV     R6,A
0133 7808              MOV     R0,#08H
0135 120000      E     LCALL   ?C?LSHL
0138 A804              MOV     R0,AR4
013A A905              MOV     R1,AR5
013C AA06              MOV     R2,AR6
013E AB07              MOV     R3,AR7
0140 D007              POP     AR7
0142 D006              POP     AR6
0144 D005              POP     AR5
0146 D004              POP     AR4
0148 120000      E     LCALL   ?C?LOR
014B D001              POP     AR1
014D D002              POP     AR2
014F D003              POP     AR3
0151 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3298
0154 900000      R     MOV     DPTR,#uniqueId
0157 120000      E     LCALL   ?C?PLDXDATA
015A E9                MOV     A,R1
015B 2404              ADD     A,#04H
015D F9                MOV     R1,A
015E E4                CLR     A
015F 3A                ADDC    A,R2
0160 FA                MOV     R2,A
0161 C003              PUSH    AR3
0163 C002              PUSH    AR2
0165 C001              PUSH    AR1
0167 120000      E     LCALL   ?C?LLDPTR
016A C004              PUSH    AR4
016C C005              PUSH    AR5
016E C006              PUSH    AR6
0170 C007              PUSH    AR7
0172 7B0C              MOV     R3,#0CH
0174 7A01              MOV     R2,#01H
0176 7905              MOV     R1,#05H
0178 120000      E     LCALL   _cyread8
017B E4                CLR     A
017C FC                MOV     R4,A
017D FD                MOV     R5,A
017E FE                MOV     R6,A
017F 7810              MOV     R0,#010H
0181 120000      E     LCALL   ?C?LSHL
0184 A804              MOV     R0,AR4
0186 A905              MOV     R1,AR5
0188 AA06              MOV     R2,AR6
018A AB07              MOV     R3,AR7
018C D007              POP     AR7
018E D006              POP     AR6
0190 D005              POP     AR5
0192 D004              POP     AR4
0194 120000      E     LCALL   ?C?LOR
0197 D001              POP     AR1
0199 D002              POP     AR2
019B D003              POP     AR3
019D 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3299
01A0 900000      R     MOV     DPTR,#uniqueId
01A3 120000      E     LCALL   ?C?PLDXDATA
01A6 E9                MOV     A,R1
01A7 2404              ADD     A,#04H
C51 COMPILER V9.51   CYLIB                                                                 02/02/2016 10:48:35 PAGE 103 

01A9 F9                MOV     R1,A
01AA E4                CLR     A
01AB 3A                ADDC    A,R2
01AC FA                MOV     R2,A
01AD C003              PUSH    AR3
01AF C002              PUSH    AR2
01B1 C001              PUSH    AR1
01B3 120000      E     LCALL   ?C?LLDPTR
01B6 C004              PUSH    AR4
01B8 C005              PUSH    AR5
01BA C006              PUSH    AR6
01BC C007              PUSH    AR7
01BE 7B0C              MOV     R3,#0CH
01C0 7A01              MOV     R2,#01H
01C2 7906              MOV     R1,#06H
01C4 120000      E     LCALL   _cyread8
01C7 E4                CLR     A
01C8 FC                MOV     R4,A
01C9 FD                MOV     R5,A
01CA FE                MOV     R6,A
01CB 7818              MOV     R0,#018H
01CD 120000      E     LCALL   ?C?LSHL
01D0 A804              MOV     R0,AR4
01D2 A905              MOV     R1,AR5
01D4 AA06              MOV     R2,AR6
01D6 AB07              MOV     R3,AR7
01D8 D007              POP     AR7
01DA D006              POP     AR6
01DC D005              POP     AR5
01DE D004              POP     AR4
01E0 120000      E     LCALL   ?C?LOR
01E3 D001              POP     AR1
01E5 D002              POP     AR2
01E7 D003              POP     AR3
01E9 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3301
01EC 22                RET     
             ; FUNCTION _CyGetUniqueId (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3611    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     15      70
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
