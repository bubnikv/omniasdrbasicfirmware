C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USBFS_EPISR
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\USBFS_episr.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\USBFS_episr.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DE
                    -BUG) WL(2) PR(.\DP8051\DP8051_Keil_951\Debug/USBFS_episr.lst) CD OT(5,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\USBFS_epis
                    -r.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: USBFS_episr.c
   3          * Version 2.80
   4          *
   5          * Description:
   6          *  Data endpoint Interrupt Service Routines
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2014, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "USBFS.h"
  18          #include "USBFS_pvt.h"
  19          
  20          #if (defined(USBFS_ENABLE_MIDI_STREAMING) && (USBFS_ENABLE_MIDI_API != 0u))
                  #include "USBFS_midi.h"
              #endif /* (defined(USBFS_ENABLE_MIDI_STREAMING) && (USBFS_ENABLE_MIDI_API != 0u)) */
  23          #if ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
                  #include "USBFS_EP8_DMA_Done_SR.h"
                  #include "USBFS_EP17_DMA_Done_SR.h"
              #endif /* (USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u) */
  27          
  28          
  29          /***************************************
  30          * Custom Declarations
  31          ***************************************/
  32          /* `#START CUSTOM_DECLARATIONS` Place your declaration here */
  33          
  34          /* `#END` */
  35          
  36          
  37          #if(USBFS_EP1_ISR_REMOVE == 0u)
  38          
  39          
  40              /******************************************************************************
  41              * Function Name: USBFS_EP_1_ISR
  42              *******************************************************************************
  43              *
  44              * Summary:
  45              *  Endpoint 1 Interrupt Service Routine
  46              *
  47              * Parameters:
  48              *  None.
  49              *
  50              * Return:
  51              *  None.
  52              *
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 2   

  53              ******************************************************************************/
  54              CY_ISR(USBFS_EP_1_ISR)
  55              {
  56   1              #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT)  && \
  57   1                           USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          uint8 int_en;
                      #endif /* USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3 */
  60   1      
  61   1              #ifdef USBFS_EP_1_ISR_ENTRY_CALLBACK
                          USBFS_EP_1_ISR_EntryCallback();
                      #endif /* USBFS_EP_1_ISR_ENTRY_CALLBACK */
  64   1      
  65   1              /* `#START EP1_USER_CODE` Place your code here */
  66   1      
  67   1              /* `#END` */
  68   1      
  69   1              #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
  70   1                           USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          int_en = EA;
                          CyGlobalIntEnable;  /* Make sure nested interrupt is enabled */
                      #endif /* USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3 */
  74   1      
  75   1              CY_GET_REG8(USBFS_SIE_EP1_CR0_PTR); /* Must read the mode reg */
  76   1              /* Do not toggle ISOC endpoint */
  77   1              if((USBFS_EP[USBFS_EP1].attrib & USBFS_EP_TYPE_MASK) !=
  78   1                                                                                          USBFS_EP_TYPE_ISOC)
  79   1              {
  80   2                  USBFS_EP[USBFS_EP1].epToggle ^= USBFS_EPX_CNT_DATA_TOGGLE;
  81   2              }
  82   1              USBFS_EP[USBFS_EP1].apiEpState = USBFS_EVENT_PENDING;
  83   1              CY_SET_REG8(USBFS_SIE_EP_INT_SR_PTR, CY_GET_REG8(USBFS_SIE_EP_INT_SR_PTR) &
  84   1                                                                          (uint8)~USBFS_SIE_EP_INT_EP1_MASK);
  85   1      
  86   1              #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
  87   1                           USBFS_ISR_SERVICE_MIDI_OUT)
                          if(USBFS_midi_out_ep == USBFS_EP1)
                          {
                              USBFS_MIDI_OUT_EP_Service();
                          }
                      #endif /*  USBFS_ISR_SERVICE_MIDI_OUT */
  93   1      
  94   1              /* `#START EP1_END_USER_CODE` Place your code here */
  95   1      
  96   1              /* `#END` */
  97   1      
  98   1              #ifdef USBFS_EP_1_ISR_EXIT_CALLBACK
                          USBFS_EP_1_ISR_ExitCallback();
                      #endif /* USBFS_EP_1_ISR_EXIT_CALLBACK */
 101   1      
 102   1              #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
 103   1                           USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          EA = int_en;
                      #endif /* USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3 */
 106   1          }
 107          
 108          #endif   /*  USBFS_EP1_ISR_REMOVE */
 109          
 110          
 111          #if(USBFS_EP2_ISR_REMOVE == 0u)
 112          
 113              /*******************************************************************************
 114              * Function Name: USBFS_EP_2_ISR
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 3   

 115              ********************************************************************************
 116              *
 117              * Summary:
 118              *  Endpoint 2 Interrupt Service Routine
 119              *
 120              * Parameters:
 121              *  None.
 122              *
 123              * Return:
 124              *  None.
 125              *
 126              *******************************************************************************/
 127              CY_ISR(USBFS_EP_2_ISR)
 128              {
 129   1              #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
 130   1                           USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          uint8 int_en;
                      #endif /* USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3 */
 133   1      
 134   1              #ifdef USBFS_EP_2_ISR_ENTRY_CALLBACK
                          USBFS_EP_2_ISR_EntryCallback();
                      #endif /* USBFS_EP_2_ISR_ENTRY_CALLBACK */
 137   1      
 138   1              /* `#START EP2_USER_CODE` Place your code here */
 139   1      
 140   1              /* `#END` */
 141   1      
 142   1              #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
 143   1                           USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          int_en = EA;
                          CyGlobalIntEnable;  /* Make sure nested interrupt is enabled */
                      #endif /* USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3 */
 147   1      
 148   1              CY_GET_REG8(USBFS_SIE_EP2_CR0_PTR); /* Must read the mode reg */
 149   1              /* Do not toggle ISOC endpoint */
 150   1              if((USBFS_EP[USBFS_EP2].attrib & USBFS_EP_TYPE_MASK) !=
 151   1                                                                                          USBFS_EP_TYPE_ISOC)
 152   1              {
 153   2                  USBFS_EP[USBFS_EP2].epToggle ^= USBFS_EPX_CNT_DATA_TOGGLE;
 154   2              }
 155   1              USBFS_EP[USBFS_EP2].apiEpState = USBFS_EVENT_PENDING;
 156   1              CY_SET_REG8(USBFS_SIE_EP_INT_SR_PTR, CY_GET_REG8(USBFS_SIE_EP_INT_SR_PTR)
 157   1                                                                              & (uint8)~USBFS_SIE_EP_INT_EP2_MAS
             -K);
 158   1      
 159   1              #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
 160   1                           USBFS_ISR_SERVICE_MIDI_OUT)
                          if(USBFS_midi_out_ep == USBFS_EP2)
                          {
                              USBFS_MIDI_OUT_EP_Service();
                          }
                      #endif /*  USBFS_ISR_SERVICE_MIDI_OUT */
 166   1      
 167   1              /* `#START EP2_END_USER_CODE` Place your code here */
 168   1      
 169   1              /* `#END` */
 170   1      
 171   1              #ifdef USBFS_EP_2_ISR_EXIT_CALLBACK
                          USBFS_EP_2_ISR_ExitCallback();
                      #endif /* USBFS_EP_2_ISR_EXIT_CALLBACK */
 174   1              
 175   1              #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 4   

 176   1                           USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          EA = int_en;
                      #endif /* USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3 */
 179   1          }
 180          
 181          #endif   /*  USBFS_EP2_ISR_REMOVE */
 182          
 183          
 184          #if(USBFS_EP3_ISR_REMOVE == 0u)
              
                  /*******************************************************************************
                  * Function Name: USBFS_EP_3_ISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  Endpoint 3 Interrupt Service Routine
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  CY_ISR(USBFS_EP_3_ISR)
                  {
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          uint8 int_en;
                      #endif /* USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3 */
              
                      #ifdef USBFS_EP_3_ISR_ENTRY_CALLBACK
                          USBFS_EP_3_ISR_EntryCallback();
                      #endif /* USBFS_EP_3_ISR_ENTRY_CALLBACK */
              
                      /* `#START EP3_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          int_en = EA;
                          CyGlobalIntEnable;  /* Make sure nested interrupt is enabled */
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      CY_GET_REG8(USBFS_SIE_EP3_CR0_PTR); /* Must read the mode reg */
                      /* Do not toggle ISOC endpoint */
                      if((USBFS_EP[USBFS_EP3].attrib & USBFS_EP_TYPE_MASK) !=
                                                                                                  USBFS_EP_TYPE_ISOC)
                      {
                          USBFS_EP[USBFS_EP3].epToggle ^= USBFS_EPX_CNT_DATA_TOGGLE;
                      }
                      USBFS_EP[USBFS_EP3].apiEpState = USBFS_EVENT_PENDING;
                      CY_SET_REG8(USBFS_SIE_EP_INT_SR_PTR, CY_GET_REG8(USBFS_SIE_EP_INT_SR_PTR)
                                                                                      & (uint8)~USBFS_SIE_EP_INT_EP3_MAS
             -K);
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT)
                          if(USBFS_midi_out_ep == USBFS_EP3)
                          {
                              USBFS_MIDI_OUT_EP_Service();
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 5   

                          }
                      #endif /*  USBFS_ISR_SERVICE_MIDI_OUT */
              
                      /* `#START EP3_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #ifdef USBFS_EP_3_ISR_EXIT_CALLBACK
                          USBFS_EP_3_ISR_ExitCallback();
                      #endif /* USBFS_EP_3_ISR_EXIT_CALLBACK */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          EA = int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
                  }
              
              #endif   /*  USBFS_EP3_ISR_REMOVE */
 255          
 256          
 257          #if(USBFS_EP4_ISR_REMOVE == 0u)
              
                  /*******************************************************************************
                  * Function Name: USBFS_EP_4_ISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  Endpoint 4 Interrupt Service Routine
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  CY_ISR(USBFS_EP_4_ISR)
                  {
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          uint8 int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      #ifdef USBFS_EP_4_ISR_ENTRY_CALLBACK
                          USBFS_EP_4_ISR_EntryCallback();
                      #endif /* USBFS_EP_4_ISR_ENTRY_CALLBACK */
              
                      /* `#START EP4_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          int_en = EA;
                          CyGlobalIntEnable;  /* Make sure nested interrupt is enabled */
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      CY_GET_REG8(USBFS_SIE_EP4_CR0_PTR); /* Must read the mode reg */
                      /* Do not toggle ISOC endpoint */
                      if((USBFS_EP[USBFS_EP4].attrib & USBFS_EP_TYPE_MASK) !=
                                                                                                  USBFS_EP_TYPE_ISOC)
                      {
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 6   

                          USBFS_EP[USBFS_EP4].epToggle ^= USBFS_EPX_CNT_DATA_TOGGLE;
                      }
                      USBFS_EP[USBFS_EP4].apiEpState = USBFS_EVENT_PENDING;
                      CY_SET_REG8(USBFS_SIE_EP_INT_SR_PTR, CY_GET_REG8(USBFS_SIE_EP_INT_SR_PTR)
                                                                                      & (uint8)~USBFS_SIE_EP_INT_EP4_MAS
             -K);
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT)
                          if(USBFS_midi_out_ep == USBFS_EP4)
                          {
                              USBFS_MIDI_OUT_EP_Service();
                          }
                      #endif /*  USBFS_ISR_SERVICE_MIDI_OUT */
              
                      /* `#START EP4_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #ifdef USBFS_EP_4_ISR_EXIT_CALLBACK
                          USBFS_EP_4_ISR_ExitCallback();
                      #endif /* USBFS_EP_4_ISR_EXIT_CALLBACK */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          EA = int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
                  }
              
              #endif   /*  USBFS_EP4_ISR_REMOVE */
 328          
 329          
 330          #if(USBFS_EP5_ISR_REMOVE == 0u)
              
                  /*******************************************************************************
                  * Function Name: USBFS_EP_5_ISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  Endpoint 5 Interrupt Service Routine
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  CY_ISR(USBFS_EP_5_ISR)
                  {
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          uint8 int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      #ifdef USBFS_EP_5_ISR_ENTRY_CALLBACK
                          USBFS_EP_5_ISR_EntryCallback();
                      #endif /* USBFS_EP_5_ISR_ENTRY_CALLBACK */
              
                      /* `#START EP5_USER_CODE` Place your code here */
              
                      /* `#END` */
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 7   

              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          int_en = EA;
                          CyGlobalIntEnable;  /* Make sure nested interrupt is enabled */
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      CY_GET_REG8(USBFS_SIE_EP5_CR0_PTR); /* Must read the mode reg */
                      /* Do not toggle ISOC endpoint */
                      if((USBFS_EP[USBFS_EP5].attrib & USBFS_EP_TYPE_MASK) !=
                                                                                                  USBFS_EP_TYPE_ISOC)
                      {
                          USBFS_EP[USBFS_EP5].epToggle ^= USBFS_EPX_CNT_DATA_TOGGLE;
                      }
                      USBFS_EP[USBFS_EP5].apiEpState = USBFS_EVENT_PENDING;
                      CY_SET_REG8(USBFS_SIE_EP_INT_SR_PTR, CY_GET_REG8(USBFS_SIE_EP_INT_SR_PTR)
                                                                                      & (uint8)~USBFS_SIE_EP_INT_EP5_MAS
             -K);
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT)
                          if(USBFS_midi_out_ep == USBFS_EP5)
                          {
                              USBFS_MIDI_OUT_EP_Service();
                          }
                      #endif /*  USBFS_ISR_SERVICE_MIDI_OUT */
              
                      /* `#START EP5_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #ifdef USBFS_EP_5_ISR_EXIT_CALLBACK
                          USBFS_EP_5_ISR_ExitCallback();
                      #endif /* USBFS_EP_5_ISR_EXIT_CALLBACK */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          EA = int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
                  }
              #endif   /*  USBFS_EP5_ISR_REMOVE */
 400          
 401          
 402          #if(USBFS_EP6_ISR_REMOVE == 0u)
              
                  /*******************************************************************************
                  * Function Name: USBFS_EP_6_ISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  Endpoint 6 Interrupt Service Routine
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  CY_ISR(USBFS_EP_6_ISR)
                  {
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 8   

                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          uint8 int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      #ifdef USBFS_EP_6_ISR_ENTRY_CALLBACK
                          USBFS_EP_6_ISR_EntryCallback();
                      #endif /* USBFS_EP_6_ISR_ENTRY_CALLBACK */
              
                      /* `#START EP6_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          int_en = EA;
                          CyGlobalIntEnable;  /* Make sure nested interrupt is enabled */
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      CY_GET_REG8(USBFS_SIE_EP6_CR0_PTR); /* Must read the mode reg */
                      /* Do not toggle ISOC endpoint */
                      if((USBFS_EP[USBFS_EP6].attrib & USBFS_EP_TYPE_MASK) !=
                                                                                                  USBFS_EP_TYPE_ISOC)
                      {
                          USBFS_EP[USBFS_EP6].epToggle ^= USBFS_EPX_CNT_DATA_TOGGLE;
                      }
                      USBFS_EP[USBFS_EP6].apiEpState = USBFS_EVENT_PENDING;
                      CY_SET_REG8(USBFS_SIE_EP_INT_SR_PTR, CY_GET_REG8(USBFS_SIE_EP_INT_SR_PTR)
                                                                                      & (uint8)~USBFS_SIE_EP_INT_EP6_MAS
             -K);
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT)
                          if(USBFS_midi_out_ep == USBFS_EP6)
                          {
                              USBFS_MIDI_OUT_EP_Service();
                          }
                      #endif /*  USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      /* `#START EP6_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #ifdef USBFS_EP_6_ISR_EXIT_CALLBACK
                          USBFS_EP_6_ISR_ExitCallback();
                      #endif /* USBFS_EP_6_ISR_EXIT_CALLBACK */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          EA = int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
                  }
              
              #endif   /*  USBFS_EP6_ISR_REMOVE */
 473          
 474          
 475          #if(USBFS_EP7_ISR_REMOVE == 0u)
              
                  /*******************************************************************************
                  * Function Name: USBFS_EP_7_ISR
                  ********************************************************************************
                  *
                  * Summary:
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 9   

                  *  Endpoint 7 Interrupt Service Routine
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  CY_ISR(USBFS_EP_7_ISR)
                  {
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          uint8 int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      #ifdef USBFS_EP_7_ISR_ENTRY_CALLBACK
                          USBFS_EP_7_ISR_EntryCallback();
                      #endif /* USBFS_EP_7_ISR_ENTRY_CALLBACK */
              
                      /* `#START EP7_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          int_en = EA;
                          CyGlobalIntEnable;  /* Make sure nested interrupt is enabled */
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      CY_GET_REG8(USBFS_SIE_EP7_CR0_PTR); /* Must read the mode reg */
                      /* Do not toggle ISOC endpoint */
                      if((USBFS_EP[USBFS_EP7].attrib & USBFS_EP_TYPE_MASK) !=
                                                                                                  USBFS_EP_TYPE_ISOC)
                      {
                          USBFS_EP[USBFS_EP7].epToggle ^= USBFS_EPX_CNT_DATA_TOGGLE;
                      }
                      USBFS_EP[USBFS_EP7].apiEpState = USBFS_EVENT_PENDING;
                      CY_SET_REG8(USBFS_SIE_EP_INT_SR_PTR, CY_GET_REG8(USBFS_SIE_EP_INT_SR_PTR)
                                                                                      & (uint8)~USBFS_SIE_EP_INT_EP7_MAS
             -K);
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT)
                          if(USBFS_midi_out_ep == USBFS_EP7)
                          {
                              USBFS_MIDI_OUT_EP_Service();
                          }
                      #endif /*  USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      /* `#START EP7_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #ifdef USBFS_EP_7_ISR_EXIT_CALLBACK
                          USBFS_EP_7_ISR_ExitCallback();
                      #endif /* USBFS_EP_7_ISR_EXIT_CALLBACK */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          EA = int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 10  

                  }
              
              #endif   /*  USBFS_EP7_ISR_REMOVE */
 546          
 547          
 548          #if(USBFS_EP8_ISR_REMOVE == 0u)
              
                  /*******************************************************************************
                  * Function Name: USBFS_EP_8_ISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  Endpoint 8 Interrupt Service Routine
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  CY_ISR(USBFS_EP_8_ISR)
                  {
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          uint8 int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      #ifdef USBFS_EP_8_ISR_ENTRY_CALLBACK
                          USBFS_EP_8_ISR_EntryCallback();
                      #endif /* USBFS_EP_8_ISR_ENTRY_CALLBACK */
              
                      /* `#START EP8_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          int_en = EA;
                          CyGlobalIntEnable;  /* Make sure nested interrupt is enabled */
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
              
                      CY_GET_REG8(USBFS_SIE_EP8_CR0_PTR); /* Must read the mode reg */
                      /* Do not toggle ISOC endpoint */
                      if((USBFS_EP[USBFS_EP8].attrib & USBFS_EP_TYPE_MASK) !=
                                                                                                  USBFS_EP_TYPE_ISOC)
                      {
                          USBFS_EP[USBFS_EP8].epToggle ^= USBFS_EPX_CNT_DATA_TOGGLE;
                      }
                      USBFS_EP[USBFS_EP8].apiEpState = USBFS_EVENT_PENDING;
                      CY_SET_REG8(USBFS_SIE_EP_INT_SR_PTR, CY_GET_REG8(USBFS_SIE_EP_INT_SR_PTR)
                                                                                      & (uint8)~USBFS_SIE_EP_INT_EP8_MAS
             -K);
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT)
                          if(USBFS_midi_out_ep == USBFS_EP8)
                          {
                              USBFS_MIDI_OUT_EP_Service();
                          }
                      #endif /*  USBFS_ISR_SERVICE_MIDI_OUT */
              
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 11  

                      /* `#START EP8_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #ifdef USBFS_EP_8_ISR_EXIT_CALLBACK
                          USBFS_EP_8_ISR_ExitCallback();
                      #endif /* USBFS_EP_8_ISR_EXIT_CALLBACK */
              
                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && !defined(USBFS_MAIN_SERVICE_MIDI_OUT) && \
                                   USBFS_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                          EA = int_en;
                      #endif /* CY_PSOC3 & USBFS_ISR_SERVICE_MIDI_OUT  */
                  }
              
              #endif   /*  USBFS_EP8_ISR_REMOVE */
 619          
 620          
 621          /*******************************************************************************
 622          * Function Name: USBFS_SOF_ISR
 623          ********************************************************************************
 624          *
 625          * Summary:
 626          *  Start of Frame Interrupt Service Routine
 627          *
 628          * Parameters:
 629          *  None.
 630          *
 631          * Return:
 632          *  None.
 633          *
 634          *******************************************************************************/
 635          CY_ISR(USBFS_SOF_ISR)
 636          {
 637   1          #ifdef USBFS_SOF_ISR_INTERRUPT_CALLBACK
                      USBFS_SOF_ISR_InterruptCallback();
                  #endif /* USBFS_SOF_ISR_INTERRUPT_CALLBACK */
 640   1      
 641   1          /* `#START SOF_USER_CODE` Place your code here */
 642   1      
 643   1          /* `#END` */
 644   1      }
 645          
 646          
 647          /*******************************************************************************
 648          * Function Name: USBFS_BUS_RESET_ISR
 649          ********************************************************************************
 650          *
 651          * Summary:
 652          *  USB Bus Reset Interrupt Service Routine.  Calls _Start with the same
 653          *  parameters as the last USER call to _Start
 654          *
 655          * Parameters:
 656          *  None.
 657          *
 658          * Return:
 659          *  None.
 660          *
 661          *******************************************************************************/
 662          CY_ISR(USBFS_BUS_RESET_ISR)
 663          {
 664   1          #ifdef USBFS_BUS_RESET_ISR_ENTRY_CALLBACK
                      USBFS_BUS_RESET_ISR_EntryCallback();
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 12  

                  #endif /* USBFS_BUS_RESET_ISR_ENTRY_CALLBACK */
 667   1      
 668   1          /* `#START BUS_RESET_USER_CODE` Place your code here */
 669   1      
 670   1          /* `#END` */
 671   1      
 672   1          USBFS_ReInitComponent();
 673   1      
 674   1          #ifdef USBFS_BUS_RESET_ISR_EXIT_CALLBACK
                      USBFS_BUS_RESET_ISR_ExitCallback();
                  #endif /* USBFS_BUS_RESET_ISR_EXIT_CALLBACK */    
 677   1      }
 678          
 679          
 680          #if((USBFS_EP_MM != USBFS__EP_MANUAL) && (USBFS_ARB_ISR_REMOVE == 0u))
              
              
                  /*******************************************************************************
                  * Function Name: USBFS_ARB_ISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  Arbiter Interrupt Service Routine
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side effect:
                  *  Search for EP8 int_status will be much slower than search for EP1 int_status.
                  *
                  *******************************************************************************/
                  CY_ISR(USBFS_ARB_ISR)
                  {
                      uint8 int_status;
                      uint8 ep_status;
                      uint8 ep = USBFS_EP1;
                      uint8 ptr = 0u;
              
                      #ifdef USBFS_ARB_ISR_ENTRY_CALLBACK
                          USBFS_ARB_ISR_EntryCallback();
                      #endif /* USBFS_ARB_ISR_ENTRY_CALLBACK */
              
                      /* `#START ARB_BEGIN_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      int_status = USBFS_ARB_INT_SR_REG;                   /* read Arbiter Status Register */
                      USBFS_ARB_INT_SR_REG = int_status;                   /* Clear Serviced Interrupts */
              
                      while(int_status != 0u)
                      {
                          if((int_status & 1u) != 0u)  /* If EpX interrupt present */
                          {   /* read Endpoint Status Register */
                              ep_status  = CY_GET_REG8((reg8 *)(USBFS_ARB_EP1_SR_IND + ptr));
                              /* If In Buffer Full */
                              if((ep_status & USBFS_ARB_EPX_SR_IN_BUF_FULL) != 0u)
                              {
                                  if((USBFS_EP[ep].addr & USBFS_DIR_IN) != 0u)
                                  {
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 13  

                                      /* Clear Data ready status */
                                      *(reg8 *)(USBFS_ARB_EP1_CFG_IND + ptr) &=
                                                                                  (uint8)~USBFS_ARB_EPX_CFG_IN_DATA_RDY;
                                      #if((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
                                          /* Setup common area DMA with rest of the data */
                                          if(USBFS_inLength[ep] > USBFS_DMA_BYTES_PER_BURST)
                                          {
                                              USBFS_LoadNextInEP(ep, 0u);
                                          }
                                          else
                                          {
                                              USBFS_inBufFull[ep] = 1u;
                                          }
                                      #endif /* ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
                                      /* Write the Mode register */
                                      CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CR0_IND + ptr), USBFS_EP[ep].epMode);
                                      #if (defined(USBFS_ENABLE_MIDI_STREAMING) && USBFS_ISR_SERVICE_MIDI_IN)
                                          if(ep == USBFS_midi_in_ep)
                                          {   /* Clear MIDI input pointer */
                                              USBFS_midiInPointer = 0u;
                                          }
                                      #endif /*  USBFS_ENABLE_MIDI_STREAMING*/
                                  }
                              }
                              /* (re)arm Out EP only for mode2 */
                              #if(USBFS_EP_MM != USBFS__EP_DMAAUTO)
                                  /* If DMA Grant */
                                  if((ep_status & USBFS_ARB_EPX_SR_DMA_GNT) != 0u)
                                  {
                                      if((USBFS_EP[ep].addr & USBFS_DIR_IN) == 0u)
                                      {
                                              USBFS_EP[ep].apiEpState = USBFS_NO_EVENT_PENDING;
                                              /* Write the Mode register */
                                              CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CR0_IND + ptr),
                                                                                                  USBFS_EP[ep].epMode);
                                      }
                                  }
                              #endif /*  USBFS_EP_MM */
              
                              /* `#START ARB_USER_CODE` Place your code here for handle Buffer Underflow/Overflow */
              
                              /* `#END` */
              
                              #ifdef USBFS_ARB_ISR_CALLBACK
                                  USBFS_ARB_ISR_Callback();
                              #endif /* USBFS_ARB_ISR_CALLBACK */
              
                              CY_SET_REG8((reg8 *)(USBFS_ARB_EP1_SR_IND + ptr), ep_status);   /* Clear Serviced events *
             -/
                          }
                          ptr += USBFS_EPX_CNTX_ADDR_OFFSET;               /* prepare pointer for next EP */
                          ep++;
                          int_status >>= 1u;
                      }
              
                      /* `#START ARB_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #ifdef USBFS_ARB_ISR_EXIT_CALLBACK
                          USBFS_ARB_ISR_ExitCallback();
                      #endif /* USBFS_ARB_ISR_EXIT_CALLBACK */
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 14  

                  }
              
              #endif /*  USBFS_EP_MM */
 792          
 793          #if ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
                  /******************************************************************************
                  * Function Name: USBFS_EP_DMA_DONE_ISR
                  *******************************************************************************
                  *
                  * Summary:
                  *  Endpoint 1 DMA Done Interrupt Service Routine
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  ******************************************************************************/
                  CY_ISR(USBFS_EP_DMA_DONE_ISR)
                  {
                      uint8 int8Status;
                      uint8 int17Status;
                      uint8 ep_status;
                      uint8 ep = USBFS_EP1;
                      uint8 ptr = 0u;
              
                      #ifdef USBFS_EP_DMA_DONE_ISR_ENTRY_CALLBACK
                          USBFS_EP_DMA_DONE_ISR_EntryCallback();
                      #endif /* USBFS_EP_DMA_DONE_ISR_ENTRY_CALLBACK */
              
                      /* `#START EP_DMA_DONE_BEGIN_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      /* Read clear on read status register with the EP source of interrupt */
                      int17Status = USBFS_EP17_DMA_Done_SR_Read() & USBFS_EP17_SR_MASK;
                      int8Status = USBFS_EP8_DMA_Done_SR_Read() & USBFS_EP8_SR_MASK;
              
                      while(int8Status != 0u)
                      {
                          while(int17Status != 0u)
                          {
                              if((int17Status & 1u) != 0u)  /* If EpX interrupt present */
                              {
                                  /* Read Endpoint Status Register */
                                  ep_status = CY_GET_REG8((reg8 *)(USBFS_ARB_EP1_SR_IND + ptr));
                                  if( ((ep_status & USBFS_ARB_EPX_SR_IN_BUF_FULL) == 0u) &&
                                      (USBFS_inBufFull[ep] == 0u))
                                  {
                                      /* `#START EP_DMA_DONE_USER_CODE` Place your code here */
              
                                      /* `#END` */
              
                                      #ifdef USBFS_EP_DMA_DONE_ISR_CALLBACK
                                          USBFS_EP_DMA_DONE_ISR_Callback();
                                      #endif /* USBFS_EP_DMA_DONE_ISR_CALLBACK */
              
                                      CY_SET_REG8((reg8 *)(USBFS_ARB_RW1_WA_MSB_IND + ptr), 0x00u);
                                      /* repeat 2 last bytes to prefetch endpoint area */
                                      CY_SET_REG8((reg8 *)(USBFS_ARB_RW1_WA_IND + ptr),
                                                  USBFS_DMA_BYTES_PER_BURST * ep - USBFS_DMA_BYTES_REPEAT);
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 15  

                                      USBFS_LoadNextInEP(ep, 1);
                                      /* Set Data ready status, This will generate DMA request */
                                      * (reg8 *)(USBFS_ARB_EP1_CFG_IND + ptr) |= USBFS_ARB_EPX_CFG_IN_DATA_RDY;
                                  }
                              }
                              ptr += USBFS_EPX_CNTX_ADDR_OFFSET;               /* prepare pointer for next EP */
                              ep++;
                              int17Status >>= 1u;
                          }
                          int8Status >>= 1u;
                          if(int8Status != 0u)
                          {
                              /* Prepare pointer for EP8 */
                              ptr = ((USBFS_EP8 - USBFS_EP1) << USBFS_EPX_CNTX_ADDR_SHIFT);
                              ep = USBFS_EP8;
                              int17Status = int8Status & 0x01u;
                          }
                      }
              
                      /* `#START EP_DMA_DONE_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                      #ifdef USBFS_EP_DMA_DONE_ISR_EXIT_CALLBACK
                          USBFS_EP_DMA_DONE_ISR_ExitCallback();
                      #endif /* USBFS_EP_DMA_DONE_ISR_EXIT_CALLBACK */
                  }
              #endif /* ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
 879          
 880          
 881          /* [] END OF FILE */
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 16  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION USBFS_EP_1_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
000F C000        E     PUSH    ?C?XPAGE1SFR
0011 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0014 C0D0              PUSH    PSW
0016 75D000            MOV     PSW,#00H
0019 C007              PUSH    AR7
                                           ; SOURCE LINE # 54
                                           ; SOURCE LINE # 75
001B 90600E            MOV     DPTR,#0600EH
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
                                           ; SOURCE LINE # 77
0020 900000      E     MOV     DPTR,#USBFS_EP+0BH
0023 E0                MOVX    A,@DPTR
0024 5403              ANL     A,#03H
0026 6401              XRL     A,#01H
0028 6007              JZ      ?C0001
                                           ; SOURCE LINE # 79
                                           ; SOURCE LINE # 80
002A 900000      E     MOV     DPTR,#USBFS_EP+0EH
002D E0                MOVX    A,@DPTR
002E 6480              XRL     A,#080H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 81
0031         ?C0001:
                                           ; SOURCE LINE # 82
0031 900000      E     MOV     DPTR,#USBFS_EP+0CH
0034 7401              MOV     A,#01H
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 84
0037 90600B            MOV     DPTR,#0600BH
003A E0                MOVX    A,@DPTR
003B 54FE              ANL     A,#0FEH
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 106
003E D007              POP     AR7
0040 D0D0              POP     PSW
0042 D000        E     POP     ?C?XPAGE1SFR
0044 D086              POP     DPS
0046 D084              POP     DPL1
0048 D085              POP     DPH1
004A D082              POP     DPL
004C D083              POP     DPH
004E D0E0              POP     ACC
0050 32                RETI    
             ; FUNCTION USBFS_EP_1_ISR (END)

             ; FUNCTION USBFS_EP_2_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 17  

0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
000F C000        E     PUSH    ?C?XPAGE1SFR
0011 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0014 C0D0              PUSH    PSW
0016 75D000            MOV     PSW,#00H
0019 C007              PUSH    AR7
                                           ; SOURCE LINE # 127
                                           ; SOURCE LINE # 148
001B 90601E            MOV     DPTR,#0601EH
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
                                           ; SOURCE LINE # 150
0020 900000      E     MOV     DPTR,#USBFS_EP+016H
0023 E0                MOVX    A,@DPTR
0024 5403              ANL     A,#03H
0026 6401              XRL     A,#01H
0028 6007              JZ      ?C0003
                                           ; SOURCE LINE # 152
                                           ; SOURCE LINE # 153
002A 900000      E     MOV     DPTR,#USBFS_EP+019H
002D E0                MOVX    A,@DPTR
002E 6480              XRL     A,#080H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
0031         ?C0003:
                                           ; SOURCE LINE # 155
0031 900000      E     MOV     DPTR,#USBFS_EP+017H
0034 7401              MOV     A,#01H
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 157
0037 90600B            MOV     DPTR,#0600BH
003A E0                MOVX    A,@DPTR
003B 54FD              ANL     A,#0FDH
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
003E D007              POP     AR7
0040 D0D0              POP     PSW
0042 D000        E     POP     ?C?XPAGE1SFR
0044 D086              POP     DPS
0046 D084              POP     DPL1
0048 D085              POP     DPH1
004A D082              POP     DPL
004C D083              POP     DPH
004E D0E0              POP     ACC
0050 32                RETI    
             ; FUNCTION USBFS_EP_2_ISR (END)

             ; FUNCTION USBFS_SOF_ISR (BEGIN)
                                           ; SOURCE LINE # 635
                                           ; SOURCE LINE # 644
0000 32                RETI    
             ; FUNCTION USBFS_SOF_ISR (END)

             ; FUNCTION USBFS_BUS_RESET_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
C51 COMPILER V9.51   USBFS_EPISR                                                           01/07/2016 22:10:56 PAGE 18  

000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C000        E     PUSH    ?C?XPAGE1SFR
0013 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0016 C0D0              PUSH    PSW
0018 75D000            MOV     PSW,#00H
001B C000              PUSH    AR0
001D C001              PUSH    AR1
001F C002              PUSH    AR2
0021 C003              PUSH    AR3
0023 C004              PUSH    AR4
0025 C005              PUSH    AR5
0027 C006              PUSH    AR6
0029 C007              PUSH    AR7
                                           ; SOURCE LINE # 662
                                           ; SOURCE LINE # 672
002B 120000      E     LCALL   USBFS_ReInitComponent
                                           ; SOURCE LINE # 677
002E D007              POP     AR7
0030 D006              POP     AR6
0032 D005              POP     AR5
0034 D004              POP     AR4
0036 D003              POP     AR3
0038 D002              POP     AR2
003A D001              POP     AR1
003C D000              POP     AR0
003E D0D0              POP     PSW
0040 D000        E     POP     ?C?XPAGE1SFR
0042 D086              POP     DPS
0044 D084              POP     DPL1
0046 D085              POP     DPH1
0048 D082              POP     DPL
004A D083              POP     DPH
004C D0F0              POP     B
004E D0E0              POP     ACC
0050 32                RETI    
             ; FUNCTION USBFS_BUS_RESET_ISR (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    244    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
